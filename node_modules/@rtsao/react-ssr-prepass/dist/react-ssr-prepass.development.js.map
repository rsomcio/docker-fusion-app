{"version":3,"file":"react-ssr-prepass.development.js","sources":["../src/symbols.js","../src/element.js","../src/internals/context.js","../src/internals/dispatcher.js","../src/render/lazyComponent.js","../src/render/functionComponent.js","../src/render/classComponent.js","../src/visitor.js","../src/index.js"],"sourcesContent":["// @flow\n\nimport type { Node } from 'react'\nimport * as is from 'react-is'\n\n/** Literal types representing the ReactSymbol values. These values do not actually match the values from react-is! */\nexport type ReactSymbol =\n  | 'react.element' /* 0xeac7 | Symbol(react.element) */\n  | 'react.portal' /* 0xeaca | Symbol(react.portal) */\n  | 'react.fragment' /* 0xeacb | Symbol(react.fragment) */\n  | 'react.strict_mode' /* 0xeacc | Symbol(react.strict_mode) */\n  | 'react.profiler' /* 0xead2 | Symbol(react.profiler) */\n  | 'react.provider' /* 0xeacd | Symbol(react.provider) */\n  | 'react.context' /* 0xeace | Symbol(react.context) */\n  | 'react.concurrent_mode' /* 0xeacf | Symbol(react.concurrent_mode) */\n  | 'react.forward_ref' /* 0xead0 | Symbol(react.forward_ref) */\n  | 'react.suspense' /* 0xead1 | Symbol(react.suspense) */\n  | 'react.memo' /* 0xead3 | Symbol(react.memo) */\n  | 'react.lazy' /* 0xead4 | Symbol(react.lazy) */\n\nexport const REACT_ELEMENT_TYPE: 'react.element' = is.Element\nexport const REACT_PORTAL_TYPE: 'react.portal' = is.Portal\nexport const REACT_FRAGMENT_TYPE: 'react.fragment' = is.Fragment\nexport const REACT_STRICT_MODE_TYPE: 'react.strict_mode' = is.StrictMode\nexport const REACT_PROFILER_TYPE: 'react.profiler' = is.Profiler\nexport const REACT_PROVIDER_TYPE: 'react.provider' = is.ContextProvider\nexport const REACT_CONTEXT_TYPE: 'react.context' = is.ContextConsumer\nexport const REACT_CONCURRENT_MODE_TYPE: 'react.concurrent_mode' =\n  is.ConcurrentMode\nexport const REACT_FORWARD_REF_TYPE: 'react.forward_ref' = is.ForwardRef\nexport const REACT_SUSPENSE_TYPE: 'react.suspense' = is.Suspense\nexport const REACT_MEMO_TYPE: 'react.memo' = is.Memo\nexport const REACT_LAZY_TYPE: 'react.lazy' = is.Lazy\n","// @flow\n\nimport { Children, type Node, type Element, type ComponentType } from 'react'\nimport type { AbstractContext, AbstractElement } from './types'\nimport * as ReactIs from 'react-is'\n\nimport {\n  type ReactSymbol,\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE\n} from './symbols'\n\n/** Is a given Component a class component */\nexport const shouldConstruct = (Comp: ComponentType<*>): boolean %checks =>\n  (Comp: any).prototype && (Comp: any).prototype.isReactComponent\n\n/** Determine the type of element using react-is with applied fixes */\nexport const typeOf = (x: AbstractElement): ReactSymbol | void => {\n  switch (x.$$typeof) {\n    case REACT_PORTAL_TYPE:\n      return REACT_PORTAL_TYPE\n    case REACT_ELEMENT_TYPE:\n      switch (x.type) {\n        case REACT_CONCURRENT_MODE_TYPE:\n          return REACT_CONCURRENT_MODE_TYPE\n        case REACT_FRAGMENT_TYPE:\n          return REACT_FRAGMENT_TYPE\n        case REACT_PROFILER_TYPE:\n          return REACT_PROFILER_TYPE\n        case REACT_STRICT_MODE_TYPE:\n          return REACT_STRICT_MODE_TYPE\n        case REACT_SUSPENSE_TYPE:\n          return REACT_SUSPENSE_TYPE\n\n        default: {\n          switch (x.type && ((x.type: any).$$typeof: ReactSymbol)) {\n            case REACT_LAZY_TYPE:\n              return REACT_LAZY_TYPE\n            case REACT_MEMO_TYPE:\n              return REACT_MEMO_TYPE\n            case REACT_CONTEXT_TYPE:\n              return REACT_CONTEXT_TYPE\n            case REACT_PROVIDER_TYPE:\n              return REACT_PROVIDER_TYPE\n            case REACT_FORWARD_REF_TYPE:\n              return REACT_FORWARD_REF_TYPE\n            default:\n              return REACT_ELEMENT_TYPE\n          }\n        }\n      }\n\n    default:\n      return undefined\n  }\n}\n\ntype ScalarNode = null | boolean | string | number\n\n/** Rebound Children.toArray with modified AbstractElement types */\nconst toArray: (node?: Node) => Array<ScalarNode | AbstractElement> =\n  Children.toArray\n\n/** Checks whether the `node` is an AbstractElement */\nconst isAbstractElement = (\n  node: ScalarNode | AbstractElement\n): boolean %checks =>\n  node !== null && typeof node === 'object'\n\n/** Returns a flat AbstractElement array for a given AbstractElement node */\nexport const getChildrenArray = (node?: Node): AbstractElement[] => {\n  // $FlowFixMe\n  return toArray(node).filter(isAbstractElement)\n}\n\n/** Returns merged props given a props and defaultProps object */\nexport const computeProps = (props: Object, defaultProps: void | Object) => {\n  return typeof defaultProps === 'object'\n    ? Object.assign({}, defaultProps, props)\n    : props\n}\n","// @flow\n\nimport type {\n  AbstractContext,\n  UserElement,\n  ContextMap,\n  ContextStore,\n  ContextEntry\n} from '../types'\n\n/** The context is kept as a Map from a Context value to the current\n   value on the React element tree.\n   The legacy context is kept as a simple object.\n   When the tree is being walked modifications are made by assigning\n   new legacy context maps or new context values.\n   These changes are kept in the `prev` variables and must be flushed\n   before continuing to walk the tree.\n   After walking the children they can be restored.\n   This way the context recursively restores itself on the way up. */\n\nlet currentContextStore: ContextStore = new Map()\nlet currentContextMap: ContextMap = {}\n\nlet prevContextMap: void | ContextMap = undefined\nlet prevContextEntry: void | ContextEntry = undefined\n\nexport const getCurrentContextMap = (): ContextMap =>\n  Object.assign({}, currentContextMap)\nexport const getCurrentContextStore = (): ContextStore =>\n  new Map(currentContextStore)\n\nexport const flushPrevContextMap = (): void | ContextMap => {\n  const prev = prevContextMap\n  prevContextMap = undefined\n  return prev\n}\n\nexport const flushPrevContextStore = (): void | ContextEntry => {\n  const prev = prevContextEntry\n  prevContextEntry = undefined\n  return prev\n}\n\nexport const restoreContextMap = (prev: void | ContextMap) => {\n  if (prev !== undefined) {\n    Object.assign(currentContextMap, prev)\n  }\n}\n\nexport const restoreContextStore = (prev: void | ContextEntry) => {\n  if (prev !== undefined) {\n    currentContextStore.set(prev[0], prev[1])\n  }\n}\n\nexport const setCurrentContextMap = (map: ContextMap) => {\n  prevContextMap = undefined\n  currentContextMap = map\n}\n\nexport const setCurrentContextStore = (store: ContextStore) => {\n  prevContextEntry = undefined\n  currentContextStore = store\n}\n\nexport const assignContextMap = (map: ContextMap) => {\n  prevContextMap = {}\n  for (const name in map) {\n    prevContextMap[name] = currentContextMap[name]\n    currentContextMap[name] = map[name]\n  }\n}\n\nexport const setContextValue = (context: AbstractContext, value: mixed) => {\n  prevContextEntry = [context, currentContextStore.get(context)]\n  currentContextStore.set(context, value)\n}\n\nexport const readContextValue = (context: AbstractContext) => {\n  const value = currentContextStore.get(context)\n  if (value !== undefined) {\n    return value\n  }\n\n  // Return default if context has no value yet\n  return context._currentValue\n}\n\nconst emptyContext = {}\n\nexport const maskContext = (type: $PropertyType<UserElement, 'type'>) => {\n  const { contextType, contextTypes } = type\n\n  if (contextType) {\n    return readContextValue(contextType)\n  } else if (!contextTypes) {\n    return emptyContext\n  }\n\n  const maskedContext = {}\n  for (const name in contextTypes) {\n    maskedContext[name] = currentContextMap[name]\n  }\n\n  return maskedContext\n}\n","// @flow\n// Source: https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js\n\nimport is from 'object-is'\nimport { readContextValue } from './context'\n\nimport type {\n  AbstractContext,\n  BasicStateAction,\n  Dispatch,\n  Update,\n  UpdateQueue,\n  Hook\n} from '../types'\n\nexport opaque type Identity = {}\n\nlet currentIdentity: Identity | null = null\n\nexport const makeIdentity = (): Identity => ({})\n\nexport const setCurrentIdentity = (id: Identity | null) => {\n  currentIdentity = id\n}\n\nexport const getCurrentIdentity = (): Identity => {\n  if (currentIdentity === null) {\n    throw new Error(\n      '[react-ssr-prepass] Hooks can only be called inside the body of a function component. ' +\n        '(https://fb.me/react-invalid-hook-call)'\n    )\n  }\n\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L63-L71\n\n  return (currentIdentity: Identity)\n}\n\nlet firstWorkInProgressHook: Hook | null = null\nlet workInProgressHook: Hook | null = null\n// Whether the work-in-progress hook is a re-rendered hook\nlet isReRender: boolean = false\n// Whether an update was scheduled during the currently executing render pass.\nlet didScheduleRenderPhaseUpdate: boolean = false\n// Lazily created map of render-phase updates\nlet renderPhaseUpdates: Map<UpdateQueue<any>, Update<any>> | null = null\n// Counter to prevent infinite loops.\nlet numberOfReRenders: number = 0\nconst RE_RENDER_LIMIT = 25\n\nexport const getFirstHook = (): Hook | null => firstWorkInProgressHook\n\nexport const setFirstHook = (hook: Hook | null) => {\n  firstWorkInProgressHook = hook\n}\n\nfunction areHookInputsEqual(\n  nextDeps: Array<mixed>,\n  prevDeps: Array<mixed> | null\n) {\n  // NOTE: The warnings that are used in ReactPartialRendererHooks are obsolete\n  // in a prepass, since these issues will be caught by a subsequent renderer anyway\n  if (prevDeps === null) {\n    return false\n  }\n\n  for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (!is(nextDeps[i], prevDeps[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction createHook(): Hook {\n  return {\n    memoizedState: null,\n    queue: null,\n    next: null\n  }\n}\n\nfunction createWorkInProgressHook(): Hook {\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    if (firstWorkInProgressHook === null) {\n      isReRender = false\n      firstWorkInProgressHook = workInProgressHook = createHook()\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      isReRender = true\n      workInProgressHook = firstWorkInProgressHook\n    }\n  } else {\n    if (workInProgressHook.next === null) {\n      isReRender = false\n      // Append to the end of the list\n      workInProgressHook = workInProgressHook.next = createHook()\n    } else {\n      // There's already a work-in-progress. Reuse it.\n      isReRender = true\n      workInProgressHook = workInProgressHook.next\n    }\n  }\n  return workInProgressHook\n}\n\nexport function renderWithHooks(\n  Component: any,\n  props: any,\n  refOrContext: any\n): any {\n  let children = Component(props, refOrContext)\n\n  // NOTE: Excessive rerenders won't throw but will instead abort rendering\n  // since a subsequent renderer can throw when this issue occurs instead\n  while (numberOfReRenders < RE_RENDER_LIMIT && didScheduleRenderPhaseUpdate) {\n    // Updates were scheduled during the render phase. They are stored in\n    // the `renderPhaseUpdates` map. Call the component again, reusing the\n    // work-in-progress hooks and applying the additional updates on top. Keep\n    // restarting until no more updates are scheduled.\n    didScheduleRenderPhaseUpdate = false\n    numberOfReRenders += 1\n    // Start over from the beginning of the list\n    workInProgressHook = null\n    children = Component(props, refOrContext)\n  }\n\n  // This will be reset by renderer\n  // firstWorkInProgressHook = null\n\n  numberOfReRenders = 0\n  renderPhaseUpdates = null\n  workInProgressHook = null\n\n  return children\n}\n\nfunction readContext(context: AbstractContext, _: void | number | boolean) {\n  // NOTE: The warning that is used in ReactPartialRendererHooks is obsolete\n  // in a prepass, since it'll be caught by a subsequent renderer anyway\n  // https://github.com/facebook/react/blob/c21c41e/packages/react-dom/src/server/ReactPartialRendererHooks.js#L215-L223\n  return readContextValue(context)\n}\n\nfunction useContext(context: AbstractContext, _: void | number | boolean) {\n  getCurrentIdentity()\n  return readContextValue(context)\n}\n\nfunction basicStateReducer<S>(state: S, action: BasicStateAction<S>): S {\n  // $FlowFixMe\n  return typeof action === 'function' ? action(state) : action\n}\n\nfunction useState<S>(\n  initialState: (() => S) | S\n): [S, Dispatch<BasicStateAction<S>>] {\n  return useReducer(\n    basicStateReducer,\n    // useReducer has a special case to support lazy useState initializers\n    (initialState: any)\n  )\n}\n\nfunction useReducer<S, I, A>(\n  reducer: (S, A) => S,\n  initialArg: I,\n  init?: I => S\n): [S, Dispatch<A>] {\n  const id = getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  if (isReRender) {\n    // This is a re-render. Apply the new render phase updates to the previous\n    // current hook.\n    const queue: UpdateQueue<A> = (workInProgressHook.queue: any)\n    const dispatch: Dispatch<A> = (queue.dispatch: any)\n    if (renderPhaseUpdates !== null) {\n      // Render phase updates are stored in a map of queue -> linked list\n      const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n      if (firstRenderPhaseUpdate !== undefined) {\n        renderPhaseUpdates.delete(queue)\n        let newState = workInProgressHook.memoizedState\n        let update = firstRenderPhaseUpdate\n        do {\n          // Process this render phase update. We don't have to check the\n          // priority because it will always be the same as the current\n          // render's.\n          const action = update.action\n          newState = reducer(newState, action)\n          update = update.next\n        } while (update !== null)\n\n        workInProgressHook.memoizedState = newState\n\n        return [newState, dispatch]\n      }\n    }\n    return [workInProgressHook.memoizedState, dispatch]\n  } else {\n    let initialState\n    if (reducer === basicStateReducer) {\n      // Special case for `useState`.\n      initialState =\n        typeof initialArg === 'function'\n          ? ((initialArg: any): () => S)()\n          : ((initialArg: any): S)\n    } else {\n      initialState =\n        init !== undefined ? init(initialArg) : ((initialArg: any): S)\n    }\n    workInProgressHook.memoizedState = initialState\n    const queue: UpdateQueue<A> = (workInProgressHook.queue = {\n      last: null,\n      dispatch: null\n    })\n    const dispatch: Dispatch<A> = (queue.dispatch = (dispatchAction.bind(\n      null,\n      id,\n      queue\n    ): any))\n    return [workInProgressHook.memoizedState, dispatch]\n  }\n}\n\nfunction useMemo<T>(nextCreate: () => T, deps: Array<mixed> | void | null): T {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n\n  const nextDeps = deps === undefined ? null : deps\n\n  if (workInProgressHook !== null) {\n    const prevState = workInProgressHook.memoizedState\n    if (prevState !== null) {\n      if (nextDeps !== null) {\n        const prevDeps = prevState[1]\n        if (areHookInputsEqual(nextDeps, prevDeps)) {\n          return prevState[0]\n        }\n      }\n    }\n  }\n\n  const nextValue = nextCreate()\n  workInProgressHook.memoizedState = [nextValue, nextDeps]\n  return nextValue\n}\n\nfunction useRef<T>(initialValue: T): { current: T } {\n  getCurrentIdentity()\n  workInProgressHook = createWorkInProgressHook()\n  const previousRef = workInProgressHook.memoizedState\n  if (previousRef === null) {\n    const ref = { current: initialValue }\n    workInProgressHook.memoizedState = ref\n    return ref\n  } else {\n    return previousRef\n  }\n}\n\nfunction dispatchAction<A>(\n  componentIdentity: Identity,\n  queue: UpdateQueue<A>,\n  action: A\n) {\n  if (componentIdentity === getCurrentIdentity()) {\n    // This is a render phase update. Stash it in a lazily-created map of\n    // queue -> linked list of updates. After this render pass, we'll restart\n    // and apply the stashed updates on top of the work-in-progress hook.\n    didScheduleRenderPhaseUpdate = true\n    const update: Update<A> = {\n      action,\n      next: null\n    }\n    if (renderPhaseUpdates === null) {\n      renderPhaseUpdates = new Map()\n    }\n    const firstRenderPhaseUpdate = renderPhaseUpdates.get(queue)\n    if (firstRenderPhaseUpdate === undefined) {\n      renderPhaseUpdates.set(queue, update)\n    } else {\n      // Append the update to the end of the list.\n      let lastRenderPhaseUpdate = firstRenderPhaseUpdate\n      while (lastRenderPhaseUpdate.next !== null) {\n        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next\n      }\n      lastRenderPhaseUpdate.next = update\n    }\n  } else {\n    // This means an update has happened after the function component has\n    // returned. On the server this is a no-op. In React Fiber, the update\n    // would be scheduled for a future render.\n  }\n}\n\nfunction useCallback<T>(callback: T, deps: Array<mixed> | void | null): T {\n  // Callbacks are passed as they are in the server environment.\n  return callback\n}\n\nfunction noop(): void {}\n\nexport const Dispatcher = {\n  readContext,\n  useContext,\n  useMemo,\n  useReducer,\n  useRef,\n  useState,\n  useCallback,\n  // ignore useLayout effect completely as usage of it will be caught\n  // in a subsequent render pass\n  useLayoutEffect: noop,\n  // useImperativeHandle is not run in the server environment\n  useImperativeHandle: noop,\n  // Effects are not run in the server environment.\n  useEffect: noop,\n  // Debugging effect\n  useDebugValue: noop\n}\n","// @flow\n\nimport { createElement, type Node } from 'react'\nimport type { LazyComponent, DefaultProps, LazyFrame, Frame } from '../types'\nimport { getChildrenArray } from '../element'\n\nimport {\n  setCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap\n} from '../internals'\n\nconst resolve = (type: LazyComponent): Promise<void> => {\n  type._status = 0 /* PENDING */\n\n  return type\n    ._ctor()\n    .then(Component => {\n      if (typeof Component === 'function') {\n        type._result = Component\n        type._status = 1 /* SUCCESSFUL */\n      } else if (\n        Component !== null &&\n        typeof Component === 'object' &&\n        typeof Component.default === 'function'\n      ) {\n        type._result = Component.default\n        type._status = 1 /* SUCCESSFUL */\n      } else {\n        type._status = 2 /* FAILED */\n      }\n    })\n    .catch(() => {\n      type._status = 2 /* FAILED */\n    })\n}\n\nconst render = (\n  type: LazyComponent,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  // Component has previously been fetched successfully,\n  // so create the element with passed props and return it\n  if (type._status === 1) {\n    return createElement(type._result, props)\n  }\n\n  return null\n}\n\nexport const mount = (\n  type: LazyComponent,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  // If the component has not been fetched yet, suspend this component\n  if (type._status !== 2 && type._status !== 1) {\n    queue.push({\n      contextMap: getCurrentContextMap(),\n      contextStore: getCurrentContextStore(),\n      kind: 'frame.lazy',\n      thenable: resolve(type),\n      props,\n      type\n    })\n\n    return null\n  }\n\n  return render(type, props, queue)\n}\n\nexport const update = (queue: Frame[], frame: LazyFrame): Node => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  return render(frame.type, frame.props, queue)\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { computeProps } from '../element'\n\nimport type {\n  Visitor,\n  Hook,\n  Frame,\n  HooksFrame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement\n} from '../types'\n\nimport {\n  type Identity,\n  maskContext,\n  makeIdentity,\n  setCurrentIdentity,\n  getCurrentIdentity,\n  setCurrentContextStore,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  renderWithHooks,\n  setFirstHook,\n  getFirstHook\n} from '../internals'\n\nconst makeFrame = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  thenable: Promise<any>\n) => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  id: getCurrentIdentity(),\n  hook: getFirstHook(),\n  kind: 'frame.hooks',\n  thenable,\n  props,\n  type\n})\n\nconst render = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[]\n): Node => {\n  try {\n    return renderWithHooks(\n      type,\n      computeProps(props, type.defaultProps),\n      maskContext(type)\n    )\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      throw error\n    }\n\n    queue.push(makeFrame(type, props, error))\n    return null\n  }\n}\n\n/** Mount a function component */\nexport const mount = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n): Node => {\n  setFirstHook(null)\n  setCurrentIdentity(makeIdentity())\n\n  const promise = visitor(element)\n  if (promise) {\n    queue.push(makeFrame(type, props, promise))\n    return null\n  }\n\n  return render(type, props, queue)\n}\n\n/** Update a previously suspended function component */\nexport const update = (queue: Frame[], frame: HooksFrame) => {\n  setFirstHook(frame.hook)\n  setCurrentIdentity(frame.id)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  return render(frame.type, frame.props, queue)\n}\n","// @flow\n\nimport type { Node, ComponentType } from 'react'\nimport { computeProps } from '../element'\n\nimport type {\n  Visitor,\n  Frame,\n  ClassFrame,\n  DefaultProps,\n  ComponentStatics,\n  UserElement\n} from '../types'\n\nimport {\n  maskContext,\n  assignContextMap,\n  setCurrentIdentity,\n  setCurrentContextMap,\n  getCurrentContextMap,\n  setCurrentContextStore,\n  getCurrentContextStore\n} from '../internals'\n\nconst createUpdater = () => {\n  const queue = []\n\n  return {\n    queue,\n    isMounted: () => false,\n    enqueueForceUpdate: () => null,\n    enqueueReplaceState: (instance, completeState) => {\n      if (instance._isMounted) {\n        queue.length = 0\n        queue.push(completeState)\n      }\n    },\n    enqueueSetState: (instance, currentPartialState) => {\n      if (instance._isMounted) {\n        queue.push(currentPartialState)\n      }\n    }\n  }\n}\n\nconst flushEnqueuedState = (instance: any) => {\n  const queue = (instance.updater.queue: any[])\n\n  if (queue.length > 0) {\n    let nextState = Object.assign({}, instance.state)\n\n    for (let i = 0, l = queue.length; i < l; i++) {\n      const partial = queue[i]\n      const partialState =\n        typeof partial === 'function'\n          ? partial.call(instance, nextState, instance.props, instance.context)\n          : partial\n      if (partialState !== null) {\n        Object.assign(nextState, partialState)\n      }\n    }\n\n    instance.state = nextState\n    queue.length = 0\n  }\n}\n\nconst createInstance = (type: any, props: DefaultProps) => {\n  const updater = createUpdater()\n  const computedProps = computeProps(props, type.defaultProps)\n  const context = maskContext(type)\n  const instance = new type(computedProps, context, updater)\n\n  instance.props = computedProps\n  instance.context = context\n  instance.updater = updater\n  instance._isMounted = true\n\n  if (instance.state === undefined) {\n    instance.state = null\n  }\n\n  if (typeof type.getDerivedStateFromProps === 'function') {\n    const { getDerivedStateFromProps } = type\n    const state = getDerivedStateFromProps(instance.props, instance.state)\n    if (state !== null && state !== undefined) {\n      instance.state = Object.assign({}, instance.state, state)\n    }\n  } else if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount()\n  } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount()\n  }\n\n  return instance\n}\n\nconst makeFrame = (type: any, instance: any, thenable: Promise<any>) => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  thenable,\n  kind: 'frame.class',\n  instance,\n  type\n})\n\nconst render = (type: any, instance: any, queue: Frame[]) => {\n  // Flush all queued up state changes\n  flushEnqueuedState(instance)\n  let child: Node = null\n\n  try {\n    child = instance.render()\n  } catch (error) {\n    if (typeof error.then !== 'function') {\n      throw error\n    }\n\n    queue.push(makeFrame(type, instance, error))\n    return null\n  }\n\n  if (\n    type.childContextTypes !== undefined &&\n    typeof instance.getChildContext === 'function'\n  ) {\n    const childContext = instance.getChildContext()\n    if (childContext !== null && typeof childContext === 'object') {\n      assignContextMap(childContext)\n    }\n  }\n\n  if (\n    typeof instance.getDerivedStateFromProps !== 'function' &&\n    (typeof instance.componentWillMount === 'function' ||\n      typeof instance.UNSAFE_componentWillMount === 'function') &&\n    typeof instance.componentWillUnmount === 'function'\n  ) {\n    try {\n      instance.componentWillUnmount()\n    } catch (_err) {}\n  }\n\n  instance._isMounted = false\n  return child\n}\n\n/** Mount a class component */\nexport const mount = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n) => {\n  setCurrentIdentity(null)\n\n  const instance = createInstance(type, props)\n  const promise = visitor(element, instance)\n  if (promise) {\n    queue.push(makeFrame(type, instance, promise))\n    return null\n  }\n\n  return render(type, instance, queue)\n}\n\n/** Update a previously suspended class component */\nexport const update = (queue: Frame[], frame: ClassFrame) => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n  return render(frame.type, frame.instance, queue)\n}\n","// @flow\n\nimport { type Node, type ComponentType, createElement } from 'react'\n\nimport {\n  typeOf,\n  shouldConstruct,\n  getChildrenArray,\n  computeProps\n} from './element'\n\nimport {\n  mountFunctionComponent,\n  mountClassComponent,\n  mountLazyComponent\n  // mountStyledComponent,\n  // isStyledElement\n} from './render'\n\nimport type {\n  Visitor,\n  YieldFrame,\n  Frame,\n  ContextMap,\n  ContextEntry,\n  DefaultProps,\n  ComponentStatics,\n  LazyElement,\n  AbstractElement,\n  ConsumerElement,\n  ProviderElement,\n  FragmentElement,\n  SuspenseElement,\n  ForwardRefElement,\n  MemoElement,\n  UserElement,\n  DOMElement\n} from './types'\n\nimport {\n  getCurrentContextMap,\n  getCurrentContextStore,\n  setCurrentContextMap,\n  setCurrentContextStore,\n  flushPrevContextMap,\n  flushPrevContextStore,\n  restoreContextMap,\n  restoreContextStore,\n  readContextValue,\n  setContextValue,\n  setCurrentIdentity\n} from './internals'\n\nimport {\n  REACT_ELEMENT_TYPE,\n  REACT_PORTAL_TYPE,\n  REACT_FRAGMENT_TYPE,\n  REACT_STRICT_MODE_TYPE,\n  REACT_PROFILER_TYPE,\n  REACT_PROVIDER_TYPE,\n  REACT_CONTEXT_TYPE,\n  REACT_CONCURRENT_MODE_TYPE,\n  REACT_FORWARD_REF_TYPE,\n  REACT_SUSPENSE_TYPE,\n  REACT_MEMO_TYPE,\n  REACT_LAZY_TYPE\n} from './symbols'\n\n// Time in ms after which the otherwise synchronous visitor yields so that\n// the event loop is not interrupted for too long\nconst YIELD_AFTER_MS = process.env.NODE_ENV !== 'production' ? 20 : 5\n\nconst render = (\n  type: ComponentType<DefaultProps> & ComponentStatics,\n  props: DefaultProps,\n  queue: Frame[],\n  visitor: Visitor,\n  element: UserElement\n) => {\n  return shouldConstruct(type)\n    ? mountClassComponent(type, props, queue, visitor, element)\n    : mountFunctionComponent(type, props, queue, visitor, element)\n}\n\nexport const visitElement = (\n  element: AbstractElement,\n  queue: Frame[],\n  visitor: Visitor\n): AbstractElement[] => {\n  switch (typeOf(element)) {\n    case REACT_SUSPENSE_TYPE:\n    case REACT_STRICT_MODE_TYPE:\n    case REACT_CONCURRENT_MODE_TYPE:\n    case REACT_PROFILER_TYPE:\n    case REACT_FRAGMENT_TYPE: {\n      // These element types are simply traversed over but otherwise ignored\n      const fragmentElement = ((element: any):\n        | FragmentElement\n        | SuspenseElement)\n      return getChildrenArray(fragmentElement.props.children)\n    }\n\n    case REACT_PROVIDER_TYPE: {\n      const providerElement = ((element: any): ProviderElement)\n      // Add provider's value prop to context\n      const { value, children } = providerElement.props\n      setContextValue(providerElement.type._context, value)\n\n      return getChildrenArray(children)\n    }\n\n    case REACT_CONTEXT_TYPE: {\n      const consumerElement = ((element: any): ConsumerElement)\n      const { children } = consumerElement.props\n\n      // Read from context and call children, if it's been passed\n      if (typeof children === 'function') {\n        const type = (consumerElement.type: any)\n        const context = typeof type._context === 'object' ? type._context : type\n        const value = readContextValue(context)\n        return getChildrenArray(children(value))\n      } else {\n        return []\n      }\n    }\n\n    case REACT_LAZY_TYPE: {\n      const lazyElement = ((element: any): LazyElement)\n      const type = lazyElement.type\n      const child = mountLazyComponent(type, lazyElement.props, queue)\n      return getChildrenArray(child)\n    }\n\n    case REACT_MEMO_TYPE: {\n      const memoElement = ((element: any): MemoElement)\n      const type = memoElement.type.type\n      const child = createElement((type: any), memoElement.props)\n      return getChildrenArray(child)\n    }\n\n    case REACT_FORWARD_REF_TYPE: {\n      const refElement = ((element: any): ForwardRefElement)\n\n      // If we find a StyledComponent, we trigger a specific optimisation\n      // that allows quick rendering of them without computing styles\n      // if (isStyledElement(refElement)) {\n      //   return mountStyledComponent(refElement)\n      // }\n\n      const { render: type, defaultProps } = refElement.type\n      const props = computeProps(refElement.props, defaultProps)\n      const fauxElement = (createElement((render: any), props): any)\n      const child = render(type, props, queue, visitor, fauxElement)\n      return getChildrenArray(child)\n    }\n\n    case REACT_ELEMENT_TYPE: {\n      const el = ((element: any): UserElement | DOMElement)\n      if (typeof el.type === 'string') {\n        // String elements can be skipped, so we just return children\n        return getChildrenArray(el.props.children)\n      } else {\n        const userElement = ((element: any): UserElement)\n        const { type, props } = userElement\n        const child = render(type, props, queue, visitor, userElement)\n        return getChildrenArray(child)\n      }\n    }\n\n    case REACT_PORTAL_TYPE:\n    // Portals are unsupported during SSR since they're DOM-only\n    default:\n      return []\n  }\n}\n\nconst visitLoop = (\n  traversalChildren: AbstractElement[][],\n  traversalMap: Array<void | ContextMap>,\n  traversalStore: Array<void | ContextEntry>,\n  queue: Frame[],\n  visitor: Visitor\n): boolean => {\n  const start = Date.now()\n\n  while (traversalChildren.length > 0) {\n    const element = traversalChildren[traversalChildren.length - 1].shift()\n    if (element !== undefined) {\n      const children = visitElement(element, queue, visitor)\n      traversalChildren.push(children)\n      traversalMap.push(flushPrevContextMap())\n      traversalStore.push(flushPrevContextStore())\n    } else {\n      traversalChildren.pop()\n      restoreContextMap(traversalMap.pop())\n      restoreContextStore(traversalStore.pop())\n    }\n\n    if (Date.now() - start > YIELD_AFTER_MS) {\n      return true\n    }\n  }\n\n  return false\n}\n\nconst makeYieldFrame = (\n  traversalChildren: AbstractElement[][],\n  traversalMap: Array<void | ContextMap>,\n  traversalStore: Array<void | ContextEntry>\n): Frame => ({\n  contextMap: getCurrentContextMap(),\n  contextStore: getCurrentContextStore(),\n  thenable: Promise.resolve(),\n  kind: 'frame.yield',\n  children: traversalChildren,\n  map: traversalMap,\n  store: traversalStore\n})\n\nexport const visitChildren = (\n  init: AbstractElement[],\n  queue: Frame[],\n  visitor: Visitor\n) => {\n  const traversalChildren: AbstractElement[][] = [init]\n  const traversalMap: Array<void | ContextMap> = [flushPrevContextMap()]\n  const traversalStore: Array<void | ContextEntry> = [flushPrevContextStore()]\n\n  const hasYielded = visitLoop(\n    traversalChildren,\n    traversalMap,\n    traversalStore,\n    queue,\n    visitor\n  )\n\n  if (hasYielded) {\n    queue.unshift(\n      makeYieldFrame(traversalChildren, traversalMap, traversalStore)\n    )\n  }\n}\n\nexport const resumeVisitChildren = (\n  frame: YieldFrame,\n  queue: Frame[],\n  visitor: Visitor\n) => {\n  setCurrentIdentity(null)\n  setCurrentContextMap(frame.contextMap)\n  setCurrentContextStore(frame.contextStore)\n\n  const hasYielded = visitLoop(\n    frame.children,\n    frame.map,\n    frame.store,\n    queue,\n    visitor\n  )\n\n  if (hasYielded) {\n    queue.unshift(makeYieldFrame(frame.children, frame.map, frame.store))\n  }\n}\n","// @flow\n\nimport React, { type Node, type Element } from 'react'\nimport type { Visitor, YieldFrame, Frame, AbstractElement } from './types'\nimport { visitChildren, resumeVisitChildren } from './visitor'\nimport { getChildrenArray } from './element'\n\nimport {\n  updateFunctionComponent,\n  updateClassComponent,\n  updateLazyComponent\n} from './render'\n\nimport {\n  setCurrentContextStore,\n  setCurrentContextMap,\n  Dispatcher\n} from './internals'\n\nconst {\n  ReactCurrentDispatcher\n} = (React: any).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\nlet prevDispatcher = ReactCurrentDispatcher.current\n\n/** visitChildren walks all elements (depth-first) and while it walks the\n    element tree some components will suspend and put a `Frame` onto\n    the queue. Hence we recursively look at suspended components in\n    this queue, wait for their promises to resolve, and continue\n    calling visitChildren on their children. */\nconst updateWithFrame = (\n  frame: Frame,\n  queue: Frame[],\n  visitor: Visitor\n): Promise<void> => {\n  if (frame.kind === 'frame.yield') {\n    const yieldFrame: YieldFrame = frame\n\n    return new Promise(resolve => {\n      setImmediate(() => {\n        prevDispatcher = ReactCurrentDispatcher.current\n        ReactCurrentDispatcher.current = Dispatcher\n        resumeVisitChildren(yieldFrame, queue, visitor)\n        ReactCurrentDispatcher.current = prevDispatcher\n        resolve()\n      })\n    })\n  }\n\n  return frame.thenable.then(() => {\n    prevDispatcher = ReactCurrentDispatcher.current\n    ReactCurrentDispatcher.current = Dispatcher\n\n    let children = []\n\n    // Update the component after we've suspended to rerender it,\n    // at which point we'll actually get its children\n    if (frame.kind === 'frame.class') {\n      children = updateClassComponent(queue, frame)\n    } else if (frame.kind === 'frame.hooks') {\n      children = updateFunctionComponent(queue, frame)\n    } else if (frame.kind === 'frame.lazy') {\n      children = updateLazyComponent(queue, frame)\n    }\n\n    // Now continue walking the previously suspended component's\n    // children (which might also suspend)\n    visitChildren(getChildrenArray(children), queue, visitor)\n    ReactCurrentDispatcher.current = prevDispatcher\n  })\n}\n\nconst flushFrames = (queue: Frame[], visitor: Visitor): Promise<void> => {\n  if (queue.length === 0) {\n    return Promise.resolve()\n  }\n\n  return updateWithFrame(queue.shift(), queue, visitor).then(() =>\n    flushFrames(queue, visitor)\n  )\n}\n\nconst defaultVisitor = () => undefined\n\nconst renderPrepass = (element: Node, visitor?: Visitor): Promise<void> => {\n  const queue: Frame[] = []\n  const fn = visitor !== undefined ? visitor : defaultVisitor\n\n  // Context state is kept globally and is modified in-place.\n  // Before we start walking the element tree we need to reset\n  // its current state\n  setCurrentContextMap({})\n  setCurrentContextStore(new Map())\n\n  try {\n    // The \"Dispatcher\" is what handles hook calls and\n    // a React internal that needs to be set to our\n    // dispatcher and reset after we're done\n    prevDispatcher = ReactCurrentDispatcher.current\n    ReactCurrentDispatcher.current = Dispatcher\n\n    visitChildren(getChildrenArray(element), queue, fn)\n  } catch (error) {\n    return Promise.reject(error)\n  } finally {\n    ReactCurrentDispatcher.current = prevDispatcher\n  }\n\n  return flushFrames(queue, fn)\n}\n\nexport default renderPrepass\n"],"names":["const","REACT_ELEMENT_TYPE","is","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_CONCURRENT_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","toArray","Children","isAbstractElement","node","getChildrenArray","filter","computeProps","props","defaultProps","Object","let","currentContextStore","Map","currentContextMap","prevContextMap","undefined","prevContextEntry","getCurrentContextMap","getCurrentContextStore","flushPrevContextMap","prev","flushPrevContextStore","restoreContextMap","restoreContextStore","set","setCurrentContextMap","map","setCurrentContextStore","store","readContextValue","context","value","get","_currentValue","emptyContext","maskContext","type","contextType","contextTypes","maskedContext","name","currentIdentity","setCurrentIdentity","id","getCurrentIdentity","Error","firstWorkInProgressHook","workInProgressHook","isReRender","didScheduleRenderPhaseUpdate","renderPhaseUpdates","numberOfReRenders","RE_RENDER_LIMIT","setFirstHook","hook","createWorkInProgressHook","memoizedState","queue","next","basicStateReducer","state","action","useReducer","reducer","initialArg","init","dispatch","firstRenderPhaseUpdate","delete","newState","update","initialState","last","dispatchAction","bind","componentIdentity","lastRenderPhaseUpdate","noop","Dispatcher","readContext","_","useContext","useMemo","nextCreate","deps","nextDeps","prevState","areHookInputsEqual","prevDeps","i","length","nextValue","useRef","initialValue","previousRef","ref","current","useState","useCallback","callback","useLayoutEffect","useImperativeHandle","useEffect","useDebugValue","resolve","_status","_ctor","then","Component","_result","default","catch","render","createElement","makeFrame","thenable","contextMap","contextStore","kind","renderWithHooks","refOrContext","children","error","push","createInstance","updater","isMounted","enqueueForceUpdate","enqueueReplaceState","instance","completeState","_isMounted","enqueueSetState","currentPartialState","computedProps","getDerivedStateFromProps","componentWillMount","UNSAFE_componentWillMount","nextState","l","partial","partialState","call","flushEnqueuedState","child","childContextTypes","getChildContext","childContext","assignContextMap","componentWillUnmount","_err","YIELD_AFTER_MS","process","env","NODE_ENV","visitor","element","Comp","prototype","isReactComponent","promise","mountClassComponent","mountFunctionComponent","visitElement","x","$$typeof","typeOf","setContextValue","_context","mountLazyComponent","fauxElement","visitLoop","traversalChildren","traversalMap","traversalStore","start","Date","now","shift","pop","makeYieldFrame","Promise","visitChildren","unshift","resumeVisitChildren","frame","ReactCurrentDispatcher","React","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","prevDispatcher","updateWithFrame","yieldFrame","setImmediate","updateClassComponent","updateFunctionComponent","updateLazyComponent","flushFrames","defaultVisitor","fn","reject"],"mappings":"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"}