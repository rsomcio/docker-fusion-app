import assert from 'assert';
import uuidv4 from 'uuid/v4';
import UAParser from 'ua-parser-js';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// eslint-disable-next-line flowtype/generic-spacing
function createPlugin(opts) {
  return _objectSpread({
    __plugin__: true,
    stack: new Error().stack
  }, opts);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const TokenType = Object.freeze({
  Required: 0,
  Optional: 1
});

function Ref() {}

class TokenImpl {
  constructor(name, ref) {
    this.name = name;
    this.ref = ref || new Ref();
    this.type = ref ? TokenType.Optional : TokenType.Required;
    this.stacks = [{
      type: 'token',
      stack: new Error().stack
    }];

    if (!ref) {
      this.optional = new TokenImpl(name, this.ref);
    }
  }

}
function createToken(name) {
  return new TokenImpl(name);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const RouteTagsToken = createToken('RouteTagsToken');
const RenderToken = createToken('RenderToken');
const ElementToken = createToken('ElementToken');
const SSRDeciderToken = createToken('SSRDeciderToken');
const HttpServerToken = createToken('HttpServerToken');
const SSRBodyTemplateToken = createToken('SSRBodyTemplateToken');
const RoutePrefixToken = createToken('RoutePrefixToken');
const CriticalChunkIdsToken = createToken('CriticalChunkIdsToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/*
We never want developers to be able to write `ctx.template.body.push(`<div>${stuff}</div>`)`
because that allows XSS attacks by default (e.g. if stuff === '<script>alert(1)</script>')
Instead, they should use html`<div>{stuff}</div>` so interpolated data gets automatically escaped
We trust the markup outside of interpolation because it's code written by a developer with commit permissions,
which can be audited via code reviews
*/
// eslint-disable-next-line import/no-mutable-exports
let html;
let dangerouslySetHTML;
let consumeSanitizedHTML;
let escape;

{
  const forbiddenChars = {
    '<': '\\u003C',
    '>': '\\u003E',
    '"': '\\u0022',
    '&': '\\u0026',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
  };

  const replaceForbidden = c => forbiddenChars[c];

  const key = Symbol('sanitized html');

  html = ([head, ...rest], ...values) => {
    const obj = {};
    Object.defineProperty(obj, key, {
      enumerable: false,
      configurable: false,
      value: head + values.map((s, i) => escape(s) + rest[i]).join('')
    });
    return obj;
  };

  dangerouslySetHTML = str => html([str]);

  escape = str => {
    if (str && str[key] !== undefined) return consumeSanitizedHTML(str);
    return String(str).replace(/[<>&"\u2028\u2029]/g, replaceForbidden);
  };

  consumeSanitizedHTML = h => {
    if (typeof h === 'string') {
      throw new Error(`Unsanitized html. Use html\`${h}\``);
    }

    return h[key];
  };
}

const replaceEscaped = c => String.fromCodePoint(parseInt(c.slice(2), 16));

const unescape = str => {
  return str.replace(/\\u003C|\\u003E|\\u0022|\\u002F|\\u2028|\\u2029|\\u0026/g, replaceEscaped);
}; // These types are necessary due to not having an assignment in the __BROWSER__ environment


const flowHtml = html;
const flowDangerouslySetHTML = dangerouslySetHTML;
const flowConsumeSanitizedHTML = consumeSanitizedHTML;
const flowEscape = escape;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const botRegex = /(bot|crawler|spider)/i;
const SSRDecider = createPlugin({
  provides: () => {
    return ctx => {
      // If the request has one of these extensions, we assume it's not something that requires server-side rendering of virtual dom
      // TODO(#46): this check should probably look at the asset manifest to ensure asset 404s are handled correctly
      if (ctx.path.match(/\.(js|js\.map|gif|jpg|png|pdf|json|svg)$/)) return false; // Bots don't always include the accept header.

      if (ctx.headers['user-agent']) {
        const agent = ctx.headers['user-agent'];

        if (botRegex.test(agent) && ctx.method === 'GET') {
          return true;
        }
      } // The Accept header is a good proxy for whether SSR should happen
      // Requesting an HTML page via the browser url bar generates a request with `text/html` in its Accept headers
      // XHR/fetch requests do not have `text/html` in the Accept headers


      if (!ctx.headers.accept) return false;
      if (!ctx.headers.accept.includes('text/html')) return false;
      return true;
    };
  }
});
function createSSRPlugin({
  element,
  ssrDecider,
  ssrBodyTemplate
}) {
  return async function ssrPlugin(ctx, next) {
    if (!ssrDecider(ctx)) return next();
    const template = {
      htmlAttrs: {},
      bodyAttrs: {},
      title: '',
      head: [],
      body: []
    };
    ctx.element = element;
    ctx.rendered = '';
    ctx.template = template;
    ctx.type = 'text/html';
    await next(); // Allow someone to override the ssr by setting ctx.body
    // This is especially useful for things like ctx.redirect

    if (ctx.body && ctx.respond !== false) {
      return;
    }

    if (ssrBodyTemplate) {
      ctx.body = ssrBodyTemplate(ctx);
    } else {
      ctx.body = legacySSRBodyTemplate(ctx);
    }
  };
}

function legacySSRBodyTemplate(ctx) {
  const {
    htmlAttrs,
    bodyAttrs,
    title,
    head,
    body
  } = ctx.template;
  const safeAttrs = Object.keys(htmlAttrs).map(attrKey => {
    return ` ${flowEscape(attrKey)}="${flowEscape(htmlAttrs[attrKey])}"`;
  }).join('');
  const safeBodyAttrs = Object.keys(bodyAttrs).map(attrKey => {
    return ` ${flowEscape(attrKey)}="${flowEscape(bodyAttrs[attrKey])}"`;
  }).join('');
  const safeTitle = flowEscape(title);
  const safeHead = head.map(flowConsumeSanitizedHTML).join('');
  const safeBody = body.map(flowConsumeSanitizedHTML).join('');
  const preloadHintLinks = getPreloadHintLinks(ctx);
  const coreGlobals = getCoreGlobals(ctx);
  const chunkScripts = getChunkScripts(ctx);
  const bundleSplittingBootstrap = [preloadHintLinks, coreGlobals, chunkScripts].join('');
  return ['<!doctype html>', `<html${safeAttrs}>`, `<head>`, `<meta charset="utf-8" />`, `<title>${safeTitle}</title>`, `${bundleSplittingBootstrap}${safeHead}`, `</head>`, `<body${safeBodyAttrs}>${ctx.rendered}${safeBody}</body>`, '</html>'].join('');
}

function getCoreGlobals(ctx) {
  const {
    webpackPublicPath,
    nonce
  } = ctx;
  return [`<script nonce="${nonce}">`, `window.performance && window.performance.mark && window.performance.mark('firstRenderStart');`, `__ROUTE_PREFIX__ = ${JSON.stringify(ctx.prefix)};`, // consumed by ./client
  `__WEBPACK_PUBLIC_PATH__ = ${JSON.stringify(webpackPublicPath)};`, // consumed by fusion-clientries/client-entry
  `</script>`].join('');
}

function getUrls({
  chunkUrlMap,
  webpackPublicPath
}, chunks) {
  // cross origin is needed to get meaningful errors in window.onerror
  const isCrossOrigin = webpackPublicPath.startsWith('http');
  const crossOriginAttribute = isCrossOrigin ? ' crossorigin="anonymous"' : '';
  return [...new Set(chunks)].map(id => {
    let url = chunkUrlMap.get(id).get('es5');

    if (webpackPublicPath.endsWith('/')) {
      url = webpackPublicPath + url;
    } else {
      url = webpackPublicPath + '/' + url;
    }

    return {
      url,
      crossOriginAttribute
    };
  });
}

function getChunkScripts(ctx) {
  const sync = getUrls(ctx, ctx.syncChunks).map(({
    url,
    crossOriginAttribute
  }) => {
    return `<script nonce="${ctx.nonce}" defer${crossOriginAttribute} src="${url}"></script>`;
  });
  const preloaded = getUrls(ctx, ctx.preloadChunks.filter(item => !ctx.syncChunks.includes(item))).map(({
    url,
    crossOriginAttribute
  }) => {
    return `<script nonce="${ctx.nonce}" defer${crossOriginAttribute} src="${url}"></script>`;
  });
  return [...preloaded, ...sync].join('');
}

function getPreloadHintLinks(ctx) {
  const chunks = [...ctx.preloadChunks, ...ctx.syncChunks];
  const hints = getUrls(ctx, chunks).map(({
    url,
    crossOriginAttribute
  }) => {
    return `<link rel="preload"${crossOriginAttribute} href="${url}" nonce="${ctx.nonce}" as="script" />`;
  });
  return hints.join('');
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function memoize(fn) {
  const memoizeKey = Symbol('memoize-key');
  return function memoized(ctx) {
    if (ctx.memoized.has(memoizeKey)) {
      return ctx.memoized.get(memoizeKey);
    }

    const result = fn(ctx);
    ctx.memoized.set(memoizeKey, result);
    return result;
  };
}

var RouteTagsPlugin = createPlugin({
  provides: () => {
    return {
      from: memoize(ctx => {
        return {
          name: 'unknown_route'
        };
      })
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *


 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class FusionApp {
  constructor(el, render) {
    this.register = (tokenOrValue, maybeValue) => {
      const hasToken = tokenOrValue instanceof TokenImpl;
      const token = hasToken ? tokenOrValue : createToken('UnnamedPlugin');
      const value = hasToken ? maybeValue : tokenOrValue;

      if (!hasToken && (value == null || !value.__plugin__)) {
        throw new Error(process.env.NODE_ENV !== "production" ? `Cannot register ${String(tokenOrValue)} without a token. Did you accidentally register a ${'browser'} plugin on the ${'server'}?` : 'Invalid configuration registration');
      } // the renderer is a special case, since it needs to be always run last


      if (token === RenderToken) {
        this.renderer = value;
        return {
          alias: () => {
            throw new Error('Aliasing for RenderToken not supported.');
          }
        };
      }

      token.stacks.push({
        type: 'register',
        stack: new Error().stack
      });

      if (value && value.__plugin__) {
        token.stacks.push({
          type: 'plugin',
          stack: value.stack
        });
      }

      return this._register(token, value);
    };

    this.registered = new Map(); // getTokenRef(token) -> {value, aliases, enhancers}

    this.enhancerToToken = new Map(); // enhancer -> token

    this._dependedOn = new Set();
    this.plugins = []; // Token

    this.cleanups = [];
    el && this.register(ElementToken, el);
    render && this.register(RenderToken, render);
    this.register(SSRDeciderToken, SSRDecider);
    this.register(RouteTagsToken, RouteTagsPlugin);
  } // eslint-disable-next-line


  _register(token, value) {
    this.plugins.push(token);
    const {
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: []
    };

    if (value && value.__plugin__) {
      if (value.deps) {
        Object.values(value.deps).forEach(token => this._dependedOn.add(getTokenRef(token)));
      }
    }

    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });

    const alias = (sourceToken, destToken) => {
      const stack = new Error().stack;
      sourceToken.stacks.push({
        type: 'alias-from',
        stack
      });
      destToken.stacks.push({
        type: 'alias-to',
        stack
      });

      this._dependedOn.add(getTokenRef(destToken));

      if (aliases) {
        aliases.set(getTokenRef(sourceToken), destToken);
      }

      return {
        alias
      };
    };

    return {
      alias
    };
  }

  middleware(deps, middleware) {
    if (middleware === undefined) {
      middleware = () => deps;
    }

    this.register(createPlugin({
      deps,
      middleware
    }));
  }

  enhance(token, enhancer) {
    token.stacks.push({
      type: 'enhance',
      stack: new Error().stack
    });
    const {
      value,
      aliases,
      enhancers
    } = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: [],
      value: undefined
    };
    this.enhancerToToken.set(enhancer, token);

    if (enhancers && Array.isArray(enhancers)) {
      enhancers.push(enhancer);
    }

    this.registered.set(getTokenRef(token), {
      value,
      aliases,
      enhancers,
      token
    });
  }

  cleanup() {
    return Promise.all(this.cleanups.map(fn => fn()));
  }

  resolve() {
    if (!this.renderer) {
      throw new Error('Missing registration for RenderToken');
    }

    this._register(RenderToken, this.renderer);

    const resolved = new Map(); // Token.ref || Token => Service

    const nonPluginTokens = new Set(); // Token

    const resolving = new Set(); // Token.ref || Token

    const registered = this.registered; // Token.ref || Token -> {value, aliases, enhancers}

    const resolvedPlugins = []; // Plugins

    const appliedEnhancers = [];

    const resolveToken = (token, tokenAliases) => {
      // Base: if we have already resolved the type, return it
      if (tokenAliases && tokenAliases.has(getTokenRef(token))) {
        const newToken = tokenAliases.get(getTokenRef(token));

        if (newToken) {
          token = newToken;
        }
      }

      if (resolved.has(getTokenRef(token))) {
        return resolved.get(getTokenRef(token));
      } // Base: if currently resolving the same type, we have a circular dependency


      if (resolving.has(getTokenRef(token))) {
        throw new Error(`Cannot resolve circular dependency: ${token.name}`);
      } // Base: the type was never registered, throw error or provide undefined if optional


      let {
        value,
        aliases,
        enhancers
      } = registered.get(getTokenRef(token)) || {};

      if (value === undefined) {
        // Early return if token is optional
        const isOptional = token instanceof TokenImpl && token.type === TokenType.Optional;

        if (isOptional && (!enhancers || !enhancers.length)) {
          return;
        }

        const dependents = Array.from(this.registered.entries());
        /**
         * Iterate over the entire list of dependencies and find all
         * dependencies of a given token.
         */

        const findDependentTokens = () => {
          return dependents.filter(entry => {
            if (!entry[1].value || !entry[1].value.deps) {
              return false;
            }

            return Object.values(entry[1].value.deps).includes(token);
          }).map(entry => entry[1].token.name);
        };

        const findDependentEnhancers = () => {
          return appliedEnhancers.filter(([, provides]) => {
            if (!provides || !provides.deps) {
              return false;
            }

            return Object.values(provides.deps).includes(token);
          }).map(([enhancer]) => {
            const enhancedToken = this.enhancerToToken.get(enhancer);
            return `EnhancerOf<${enhancedToken ? enhancedToken.name : '(unknown)'}>`;
          });
        };

        const dependentTokens = [...findDependentTokens(), ...findDependentEnhancers()];
        const base = 'A plugin depends on a token, but the token was not registered';
        const downstreams = 'This token is required by plugins registered with tokens: ' + dependentTokens.map(token => `"${token}"`).join(', ');
        const stack = token.stacks.find(t => t.type === 'token');
        const meta = `Required token: ${token ? token.name : ''}\n${downstreams}\n${stack ? stack.stack : ''}`;
        const clue = 'Different tokens with the same name were detected:\n\n';
        const suggestions = token ? this.plugins.filter(p => p.name === token.name).map(p => {
          const stack = p.stacks.find(t => t.type === 'token');
          return `${p.name}\n${stack ? stack.stack : ''}\n\n`;
        }).join('\n\n') : '';
        const help = 'You may have multiple versions of the same plugin installed.\n' + 'Ensure that `yarn list [the-plugin]` results in one version, ' + 'and use a yarn resolution or merge package version in your lock file to consolidate versions.\n\n';
        throw new Error(`${base}\n\n${meta}\n\n${suggestions && clue + suggestions + help}`);
      } // Recursive: get the registered type and resolve it


      resolving.add(getTokenRef(token));

      function resolvePlugin(plugin) {
        const registeredDeps = plugin && plugin.deps || {};
        const resolvedDeps = {};

        for (const key in registeredDeps) {
          const registeredToken = registeredDeps[key];
          resolvedDeps[key] = resolveToken(registeredToken, aliases);
        } // `provides` should be undefined if the plugin does not have a `provides` function


        let provides = plugin && plugin.provides ? plugin.provides(resolvedDeps) : undefined;

        if (plugin && plugin.middleware) {
          resolvedPlugins.push(plugin.middleware(resolvedDeps, provides));
        }

        return provides;
      }

      let provides = value;

      if (value && value.__plugin__) {
        provides = resolvePlugin(provides);

        if (value.cleanup) {
          this.cleanups.push(function () {
            return typeof value.cleanup === 'function' ? value.cleanup(provides) : Promise.resolve();
          });
        }
      } else {
        nonPluginTokens.add(token);
      }

      if (enhancers && enhancers.length) {
        enhancers.forEach(e => {
          let nextProvides = e(provides);
          appliedEnhancers.push([e, nextProvides]);

          if (nextProvides && nextProvides.__plugin__) {
            // if the token has a plugin enhancer, allow it to be registered with no dependents
            nonPluginTokens.delete(token);

            if (nextProvides.deps) {
              Object.values(nextProvides.deps).forEach(token => this._dependedOn.add(getTokenRef(token)));
            }

            nextProvides = resolvePlugin(nextProvides);
          }

          provides = nextProvides;
        });
      }

      resolved.set(getTokenRef(token), provides);
      resolving.delete(getTokenRef(token));
      return provides;
    };

    for (let i = 0; i < this.plugins.length; i++) {
      resolveToken(this.plugins[i]);
    }

    for (const token of nonPluginTokens) {
      if (token !== ElementToken && token !== RenderToken && !this._dependedOn.has(getTokenRef(token))) {
        throw new Error(`Registered token without depending on it: "${token.name}". See https://github.com/fusionjs/fusionjs/tree/master/fusion-core#registered-without-depending.`);
      }
    }

    this.plugins = resolvedPlugins;

    this._getService = token => resolved.get(getTokenRef(token));
  }

  getService(token) {
    if (!this._getService) {
      throw new Error('Cannot get service from unresolved app');
    }

    return this._getService(token);
  }

}
/* Helper functions */


function getTokenRef(token) {
  if (token instanceof TokenImpl) {
    return token.ref;
  }

  return token;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// inline version of koa-compose to get around Rollup/CUP commonjs-related issue
function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError('Middleware stack must be an array!');
  }

  for (const fn of middleware) {
    if (typeof fn !== 'function') {
      throw new TypeError(`Expected middleware function, received: ${typeof fn}`);
    }
  }

  return function (context, next) {
    let index = -1;
    return dispatch(0);

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }

      index = i;
      let fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();

      try {
        return fn(context, function next() {
          return dispatch(i + 1);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Timing {
  constructor() {
    this.start = now();
    this.render = deferred();
    this.end = deferred();
    this.downstream = deferred();
    this.upstream = deferred();
    this.upstreamStart = -1;
  }

}

const timing = {
  from: memoize(() => new Timing())
};
const TimingToken = createToken('TimingToken');

function middleware(ctx, next) {
  ctx.memoized = new Map();
  const {
    start,
    render,
    end,
    downstream,
    upstream
  } = timing.from(ctx);
  ctx.timing = {
    start,
    render: render.promise,
    end: end.promise,
    downstream: downstream.promise,
    upstream: upstream.promise
  };
  return next().then(() => {
    const upstreamTime = now() - timing.from(ctx).upstreamStart;
    upstream.resolve(upstreamTime);
    const endTime = now() - ctx.timing.start;
    end.resolve(endTime);
  }).catch(e => {
    // currently we only resolve upstream and downstream when the request does not error
    // we should however always resolve the request end timing
    if (e && e.status) {
      // this ensures any logging / metrics based on ctx.status will recieve the correct status code
      ctx.status = e.status;
    }

    const endTime = now() - ctx.timing.start;
    end.resolve(endTime);
    throw e;
  });
}

var timing$1 = createPlugin({
  provides: () => timing,
  middleware: () => middleware
});
function now() {
  {
    const [seconds, ns] = process.hrtime();
    return Math.round(seconds * 1000 + ns / 1e6);
  }
}

function deferred() {
  let resolve = () => {};

  let reject = () => {};

  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function getRendererPlugin({
  render,
  timing
}) {
  return async function renderer(ctx, next) {
    const timer = timing.from(ctx);
    timer.downstream.resolve(now() - timer.start);
    let renderTime = null;

    if (ctx.element && !ctx.body && ctx.respond !== false) {
      const renderStart = now();
      ctx.rendered = await render(ctx.element, ctx);
      renderTime = now() - renderStart;
    }

    timer.upstreamStart = now();
    await next();

    if (ctx.element && typeof renderTime === 'number') {
      timer.render.resolve(renderTime);
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var getEnv = loadEnv();

function load(key, value) {
  return process.env[key] || value;
}

function loadEnv() {
  const rootDir = load('ROOT_DIR', '.');
  const env = load('NODE_ENV', 'development');

  if (!(env === 'development' || env === 'production' || env === 'test')) {
    throw new Error(`Invalid NODE_ENV loaded: ${env}.`);
  }

  const prefix = load('ROUTE_PREFIX', '');
  assert(!prefix.endsWith('/'), 'ROUTE_PREFIX must not end with /');
  const baseAssetPath = load('FRAMEWORK_STATIC_ASSET_PATH', `/_static`);
  assert(!baseAssetPath.endsWith('/'), 'FRAMEWORK_STATIC_ASSET_PATH must not end with /');
  const cdnUrl = load('CDN_URL', '');
  assert(!cdnUrl.endsWith('/'), 'CDN_URL must not end with /');
  const dangerouslyExposeSourceMaps = load('DANGEROUSLY_EXPOSE_SOURCE_MAPS', 'false');
  const assetPath = `${prefix}${baseAssetPath}`;
  return function loadEnv() {
    return {
      rootDir,
      env,
      prefix,
      assetPath,
      baseAssetPath,
      cdnUrl,
      webpackPublicPath: cdnUrl || assetPath,
      dangerouslyExposeSourceMaps: dangerouslyExposeSourceMaps === 'true'
    };
  };
} // Handle flow-types for export so browser export is ignored.

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const envVars = getEnv();
function middleware$1(ctx, next) {
  // env vars
  ctx.rootDir = envVars.rootDir;
  ctx.env = envVars.env;
  ctx.prefix = envVars.prefix;
  ctx.assetPath = envVars.assetPath;
  ctx.cdnUrl = envVars.cdnUrl; // webpack-related things

  ctx.preloadChunks = [];
  ctx.webpackPublicPath = ctx.webpackPublicPath || envVars.cdnUrl || envVars.assetPath; // these are set by fusion-cli, however since fusion-cli plugins are not added when
  // running simulation tests, it is good to default them here

  ctx.syncChunks = ctx.syncChunks || [];
  ctx.chunkUrlMap = ctx.chunkUrlMap || new Map(); // fusion-specific things

  ctx.nonce = uuidv4();
  ctx.useragent = new UAParser(ctx.headers['user-agent']).getResult();
  ctx.element = null;
  ctx.rendered = null;
  return next();
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
function serverApp () {
  const Koa = require('koa');

  return class ServerApp extends FusionApp {
    constructor(el, render) {
      super(el, render);
      this._app = new Koa();
      this._app.proxy = true;
      this.middleware(middleware$1);
      this.register(TimingToken, timing$1);
      this.middleware({
        element: ElementToken,
        ssrDecider: SSRDeciderToken,
        ssrBodyTemplate: SSRBodyTemplateToken.optional
      }, createSSRPlugin);
    }

    resolve() {
      this.middleware({
        timing: TimingToken,
        render: RenderToken
      }, getRendererPlugin);
      return super.resolve();
    }

    callback() {
      this.resolve();

      this._app.use(compose(this.plugins));

      return this._app.callback();
    }

  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function assetUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}
function chunkId(filename) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return filename;
}
function syncChunkIds(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function syncChunkPaths(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function workerUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var index = serverApp();

export default index;
export { getEnv, compose, memoize, flowHtml as html, flowDangerouslySetHTML as dangerouslySetHTML, flowConsumeSanitizedHTML as consumeSanitizedHTML, flowEscape as escape, unescape, assetUrl, chunkId, syncChunkIds, syncChunkPaths, workerUrl, RenderToken, ElementToken, SSRDeciderToken, HttpServerToken, SSRBodyTemplateToken, RoutePrefixToken, CriticalChunkIdsToken, RouteTagsToken, createPlugin, createToken };
