import { isValidElement, createElement, Component, Children, createContext, useContext } from 'react';
import ssrPrepass from '@rtsao/react-ssr-prepass';
import PropTypes from 'prop-types';
import ReactDOM from 'react-dom';
import FusionApp, { createPlugin, createToken, CriticalChunkIdsToken } from 'fusion-core';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class PrepareState {
  constructor() {
    this.seen = new Map();
    this.pending = new Map();
  }

  isResolved(Component$$1, effectId, effectPromiseThunk) {
    let seenEffectIds = this.seen.get(Component$$1);
    let pendingPromises = this.pending.get(Component$$1); // Initialize if not present

    if (!seenEffectIds) {
      seenEffectIds = new Set();
      this.seen.set(Component$$1, seenEffectIds);
    } // If seen and not pending, then it has been resolved


    if (seenEffectIds.has(effectId) && (!pendingPromises || !pendingPromises.has(effectId))) {
      return true;
    } // If not yet seen, need to start promise


    if (!seenEffectIds.has(effectId)) {
      if (!pendingPromises) {
        pendingPromises = new Map();
        this.pending.set(Component$$1, pendingPromises);
      }

      const effectPromise = effectPromiseThunk();
      seenEffectIds.add(effectId);
      pendingPromises.set(effectId, effectPromise);
    }

    return false;
  }

  consumeAndAwaitPromises() {
    let promises = [];

    for (let map of this.pending.values()) {
      for (let promise of map.values()) {
        promises.push(promise);
      }
    }

    this.pending = new Map(); // clear

    return Promise.all(promises);
  }

}

function prepare(element) {
  const prepareState = new PrepareState();

  class PrepareContextProvider extends Component {
    getChildContext() {
      return {
        __IS_PREPARE__: true,
        __PREPARE_STATE__: prepareState
      };
    }

    render() {
      return element;
    }

  }

  PrepareContextProvider.childContextTypes = {
    __PREPARE_STATE__: () => {},
    __IS_PREPARE__: () => {}
  };

  function process() {
    return new Promise(function ($return, $error) {
      return Promise.resolve(ssrPrepass(createElement(PrepareContextProvider))).then(function ($await_1) {
        try {
          if (prepareState.pending.size) {
            return $return(prepareState.consumeAndAwaitPromises().then(process));
          }

          return $return();
        } catch ($boundEx) {
          return $error($boundEx);
        }
      }, $error);
    });
  }

  return Promise.resolve().then(process);
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepared = (sideEffect, opts = {}) => OriginalComponent => {
  opts = Object.assign({
    boundary: false,
    defer: false,
    componentDidMount: true,
    componentWillReceiveProps: false,
    componentDidUpdate: false,
    contextTypes: {},
    forceUpdate: false
  }, opts);

  class PreparedComponent extends Component {
    componentDidMount() {
      if (opts.componentDidMount) {
        Promise.resolve(sideEffect(this.props, this.context)).then(() => {
          if (opts.forceUpdate) {
            this.forceUpdate();
          }
        });
      }
    }

    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
      if (opts.componentWillReceiveProps) {
        sideEffect(nextProps, nextContext);
      }
    }

    componentDidUpdate() {
      if (opts.componentDidUpdate) {
        sideEffect(this.props, this.context);
      }
    }

    render() {
      const effectId = this.props.effectId || 'defaultId';
      const prepareState = this.context.__PREPARE_STATE__;

      if (prepareState) {
        if (opts.defer || opts.boundary) {
          // skip prepare if defer or boundary
          return null;
        }

        const isResolved = prepareState.isResolved(PreparedComponent, effectId, () => sideEffect(this.props, this.context));

        if (!isResolved) {
          // Wait until resolved
          return null;
        }
      }

      return createElement(OriginalComponent, this.props);
    }

  }

  PreparedComponent.contextTypes = _objectSpread({
    __PREPARE_STATE__: () => {}
  }, opts.contextTypes);
  const displayName = OriginalComponent.displayName || OriginalComponent.name || '';
  PreparedComponent.displayName = `PreparedComponent(${displayName})`;
  return PreparedComponent;
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
};

function withAsyncComponent({
  defer,
  load,
  LoadingComponent,
  ErrorComponent
}) {
  let AsyncComponent = null;
  let error = null;
  const metadata = {
    chunkIds: [],
    i18nKeys: []
  };

  function WithAsyncComponent(props) {
    {
      let promise = load(); // $FlowFixMe

      let id = promise.__MODULE_ID;

      if (typeof __webpack_modules__ !== 'undefined' && __webpack_modules__[id]) {
        // If module is already loaded, it can be synchronously imported
        AsyncComponent = __webpack_require__(id).default;
      }
    }

    if (error) {
      return createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return createElement(LoadingComponent, null);
    }

    return createElement(AsyncComponent, props);
  }

  return prepared((props, context) => {
    if (AsyncComponent) {
      return Promise.resolve(AsyncComponent);
    }

    let componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    } // $FlowFixMe


    metadata.chunkIds = componentPromise.__CHUNK_IDS || []; // $FlowFixMe

    metadata.i18nKeys = componentPromise.__I18N_KEYS || [];

    const loadPromises = [componentPromise, ...context.splitComponentLoaders.map(loader => loader(metadata.chunkIds, metadata))];
    return Promise.all(loadPromises).then(([asyncComponent]) => {
      // Note: .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;

      if (AsyncComponent === undefined) {
        throw new Error('Bundle does not contain a default export');
      }
    }).catch(err => {
      error = err;
      setTimeout(() => {
        throw err;
      }); // log error
    });
  }, {
    defer,
    contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// to visit the minimum number of nodes

var traverseExclude = prepared(() => Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class PrepareProvider extends Component {
  constructor(props, context) {
    super(props, context);
    this.splitComponentLoaders = [];
    this.markAsCritical = props.markAsCritical;
  }

  getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      markAsCritical: this.markAsCritical
    };
  }

  render() {
    return Children.only(this.props.children);
  }

}

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  markAsCritical: PropTypes.func
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const middleware = function (ctx, next) {
  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line no-console
    console.warn('The {middleware} export from fusion-react is deprecated.');
  }

  const markAsCritical = noop;
  ctx.element = createElement(PrepareProvider, {
    markAsCritical: markAsCritical
  }, ctx.element);
  return next();
};

function noop() {}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
var clientRender = (el => {
  const domElement = document.getElementById('root');

  if (!domElement) {
    throw new Error("Could not find 'root' element");
  }

  return ReactDOM.hydrate ? ReactDOM.hydrate(el, domElement) : ReactDOM.render(el, domElement);
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Provider = {
  create: name => {
    class Provider extends Component {
      getChildContext() {
        return {
          [name]: this.props.provides
        };
      }

      render() {
        return Children.only(this.props.children);
      }

    }

    Provider.childContextTypes = _objectSpread$1({}, Provider.childContextTypes || {}, {
      [name]: PropTypes.any.isRequired
    });
    Provider.displayName = name.replace(/^./, c => c.toUpperCase()) + 'Provider';
    return Provider;
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var plugin = {
  create: (name, plugin, provider) => {
    if (plugin.__plugin__ === undefined) {
      plugin = createPlugin(plugin);
    }

    if (!plugin.__plugin__) {
      throw new Error('Provided plugin does not match FusionPlugin<TDeps, TService>');
    }

    let originalMiddleware = plugin.middleware;
    const ProviderComponent = provider || Provider.create(name);

    plugin.middleware = (deps, provides) => {
      let nextMiddleware = originalMiddleware && originalMiddleware(deps, provides);

      const mw = function (ctx, next) {
        if (ctx.element) {
          ctx.element = createElement(ProviderComponent, {
            provides,
            ctx
          }, ctx.element);
        }

        if (nextMiddleware) {
          return nextMiddleware(ctx, next);
        }

        return next();
      };

      return mw;
    };

    return plugin;
  }
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/** Copyright (c) 2019 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const FusionContext = createContext({});
const ServiceContext = createContext(() => {
  throw new Error('`ServiceContext.Provider` was not found. This occurs if you are attempting to use `ServiceContext` in a non-React Fusion.js application.');
});
function useService(token) {
  const getService = useContext(ServiceContext);
  const provides = getService(token);
  return provides;
}
function ServiceConsumer({
  token,
  children
}) {
  return createElement(ServiceContext.Consumer, null, getService => {
    const provides = getService(token);
    return children(provides);
  });
}

function getServices(getService, deps) {
  const services = {};
  Object.keys(deps).forEach(name => {
    services[name] = getService(deps[name]);
  });
  return services;
}

const identity = i => i;

function withServices(deps, mapServicesToProps = identity) {
  function resolve(getService) {
    const services = getServices(getService, deps);
    const serviceProps = mapServicesToProps(services);
    return serviceProps;
  }

  return Component$$1 => {
    return function WithServices(props) {
      return createElement(ServiceContext.Consumer, null, getService => createElement(Component$$1, _extends({}, resolve(getService), props)));
    };
  };
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function capitalize(str) {
  return str.replace(/^./, c => c.toUpperCase());
}

var hoc = {
  create: (name, mapProvidesToProps, token) => {
    const mapProvides = mapProvidesToProps ? mapProvidesToProps : provides => ({
      [name]: provides
    });
    const _token = token; // Make token constant for flow

    if (_token) {
      // Use new Context through useService hook
      return Component$$1 => {
        const Wrapper = props => {
          const service = useService(_token);
          return createElement(Component$$1, _objectSpread$2({}, props, {}, mapProvides(service)));
        };

        const displayName = Component$$1.displayName || Component$$1.name || 'Anonymous';
        Wrapper.displayName = `With${capitalize(name)}(${displayName})`;
        return Wrapper;
      };
    } else {
      // Use legacy Context
      return Component$$1 => {
        class HOC extends Component {
          constructor(props, ctx) {
            super(props, ctx);
            this.provides = ctx[name];
          }

          render() {
            const props = _objectSpread$2({}, this.props, {}, mapProvides(this.provides));

            return createElement(Component$$1, props);
          }

        }

        const displayName = Component$$1.displayName || Component$$1.name || 'Anonymous';
        HOC.displayName = `With${capitalize(name)}(${displayName})`;
        HOC.contextTypes = {
          [name]: PropTypes.any.isRequired
        };
        return HOC;
      };
    }
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
const SkipPrepareToken = createToken('SkipPrepareToken');
class App extends FusionApp {
  constructor(root, render) {
    if (!isValidElement(root)) {
      throw new Error('Invalid React element. Ensure your root element is a React.Element (e.g. <Foo />) and not a React.Component (e.g. Foo)');
    }

    const getService = token => {
      // $FlowFixMe
      const provides = this.getService(token);
      const isRequiredToken = Boolean(token.optional);

      if (typeof provides === 'undefined' && isRequiredToken) {
        throw new Error(`Token ${token.name} not registered or registered plugin does not provide a service. To use an optional plugin, use \`Token.optional\`.`);
      }

      return provides;
    };

    const renderer = createPlugin({
      deps: {
        criticalChunkIds: CriticalChunkIdsToken.optional,
        skipPrepare: SkipPrepareToken.optional
      },

      provides({
        skipPrepare
      }) {
        return (el, ctx) => {
          return (skipPrepare ? Promise.resolve() : prepare(el)).then(() => {
            if (render) {
              return render(el, ctx);
            }

            {
              return clientRender(el);
            }
          });
        };
      },

      middleware({
        criticalChunkIds
      }) {
        return (ctx, next) => {
          const markAsCritical = noop$1;
          ctx.element = createElement(PrepareProvider, {
            markAsCritical: markAsCritical
          }, createElement(FusionContext.Provider, {
            value: ctx
          }, createElement(ServiceContext.Provider, {
            value: getService
          }, ctx.element)));
          return next();
        };
      }

    });
    super(root, renderer);
  }

}
function noop$1() {}

export default App;
export { SkipPrepareToken, FusionContext, plugin as ProviderPlugin, hoc as ProvidedHOC, Provider, ServiceConsumer, ServiceContext, useService, withServices, prepare, prepared, withAsyncComponent as split, traverseExclude as exclude, middleware };
