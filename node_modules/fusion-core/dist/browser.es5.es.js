function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// eslint-disable-next-line flowtype/generic-spacing
function createPlugin(opts) {
  return _objectSpread({
    __plugin__: true,
    stack: new Error().stack
  }, opts);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var TokenType = Object.freeze({
  Required: 0,
  Optional: 1
});

function Ref() {}

var TokenImpl = function TokenImpl(name, ref) {
  this.name = name;
  this.ref = ref || new Ref();
  this.type = ref ? TokenType.Optional : TokenType.Required;
  this.stacks = [{
    type: 'token',
    stack: new Error().stack
  }];

  if (!ref) {
    this.optional = new TokenImpl(name, this.ref);
  }
};
function createToken(name) {
  return new TokenImpl(name);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var RouteTagsToken = createToken('RouteTagsToken');
var RenderToken = createToken('RenderToken');
var ElementToken = createToken('ElementToken');
var SSRDeciderToken = createToken('SSRDeciderToken');
var HttpServerToken = createToken('HttpServerToken');
var SSRBodyTemplateToken = createToken('SSRBodyTemplateToken');
var RoutePrefixToken = createToken('RoutePrefixToken');
var CriticalChunkIdsToken = createToken('CriticalChunkIdsToken');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/*
We never want developers to be able to write `ctx.template.body.push(`<div>${stuff}</div>`)`
because that allows XSS attacks by default (e.g. if stuff === '<script>alert(1)</script>')
Instead, they should use html`<div>{stuff}</div>` so interpolated data gets automatically escaped
We trust the markup outside of interpolation because it's code written by a developer with commit permissions,
which can be audited via code reviews
*/
// eslint-disable-next-line import/no-mutable-exports
var html;
var dangerouslySetHTML;
var consumeSanitizedHTML;
var escape;

var replaceEscaped = function replaceEscaped(c) {
  return String.fromCodePoint(parseInt(c.slice(2), 16));
};

var unescape = function unescape(str) {
  return str.replace(/\\u003C|\\u003E|\\u0022|\\u002F|\\u2028|\\u2029|\\u0026/g, replaceEscaped);
}; // These types are necessary due to not having an assignment in the __BROWSER__ environment


var flowHtml = html;
var flowDangerouslySetHTML = dangerouslySetHTML;
var flowConsumeSanitizedHTML = consumeSanitizedHTML;
var flowEscape = escape;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var botRegex = /(bot|crawler|spider)/i;
var SSRDecider = createPlugin({
  provides: function provides() {
    return function (ctx) {
      // If the request has one of these extensions, we assume it's not something that requires server-side rendering of virtual dom
      // TODO(#46): this check should probably look at the asset manifest to ensure asset 404s are handled correctly
      if (ctx.path.match(/\.(js|js\.map|gif|jpg|png|pdf|json|svg)$/)) return false; // Bots don't always include the accept header.

      if (ctx.headers['user-agent']) {
        var agent = ctx.headers['user-agent'];

        if (botRegex.test(agent) && ctx.method === 'GET') {
          return true;
        }
      } // The Accept header is a good proxy for whether SSR should happen
      // Requesting an HTML page via the browser url bar generates a request with `text/html` in its Accept headers
      // XHR/fetch requests do not have `text/html` in the Accept headers


      if (!ctx.headers.accept) return false;
      if (!ctx.headers.accept.includes('text/html')) return false;
      return true;
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function Container() {}

function memoize(fn) {
  var memoizeKey = new Container();
  return function memoized(ctx) {
    if (ctx.memoized.has(memoizeKey)) {
      return ctx.memoized.get(memoizeKey);
    }

    var result = fn(ctx);
    ctx.memoized.set(memoizeKey, result);
    return result;
  };
}

var RouteTagsPlugin = createPlugin({
  provides: function provides() {
    return {
      from: memoize(function (ctx) {
        return {
          name: 'unknown_route'
        };
      })
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *


 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var FusionApp =
/*#__PURE__*/
function () {
  function FusionApp(el, render) {
    var _this = this;

    this.register = function (tokenOrValue, maybeValue) {
      var hasToken = tokenOrValue instanceof TokenImpl;
      var token = hasToken ? tokenOrValue : createToken('UnnamedPlugin');
      var value = hasToken ? maybeValue : tokenOrValue;

      if (!hasToken && (value == null || !value.__plugin__)) {
        throw new Error(process.env.NODE_ENV !== "production" ? "Cannot register " + String(tokenOrValue) + " without a token. Did you accidentally register a " + ('server') + " plugin on the " + ('browser') + "?" : 'Invalid configuration registration');
      } // the renderer is a special case, since it needs to be always run last


      if (token === RenderToken) {
        _this.renderer = value;
        return {
          alias: function alias() {
            throw new Error('Aliasing for RenderToken not supported.');
          }
        };
      }

      token.stacks.push({
        type: 'register',
        stack: new Error().stack
      });

      if (value && value.__plugin__) {
        token.stacks.push({
          type: 'plugin',
          stack: value.stack
        });
      }

      return _this._register(token, value);
    };

    this.registered = new Map(); // getTokenRef(token) -> {value, aliases, enhancers}

    this.enhancerToToken = new Map(); // enhancer -> token

    this._dependedOn = new Set();
    this.plugins = []; // Token

    this.cleanups = [];
    el && this.register(ElementToken, el);
    render && this.register(RenderToken, render);
    this.register(SSRDeciderToken, SSRDecider);
    this.register(RouteTagsToken, RouteTagsPlugin);
  } // eslint-disable-next-line


  var _proto = FusionApp.prototype;

  _proto._register = function _register(token, value) {
    var _this2 = this;

    this.plugins.push(token);

    var _ref = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: []
    },
        aliases = _ref.aliases,
        enhancers = _ref.enhancers;

    if (value && value.__plugin__) {
      if (value.deps) {
        Object.values(value.deps).forEach(function (token) {
          return _this2._dependedOn.add(getTokenRef(token));
        });
      }
    }

    this.registered.set(getTokenRef(token), {
      value: value,
      aliases: aliases,
      enhancers: enhancers,
      token: token
    });

    var alias = function alias(sourceToken, destToken) {
      var stack = new Error().stack;
      sourceToken.stacks.push({
        type: 'alias-from',
        stack: stack
      });
      destToken.stacks.push({
        type: 'alias-to',
        stack: stack
      });

      _this2._dependedOn.add(getTokenRef(destToken));

      if (aliases) {
        aliases.set(getTokenRef(sourceToken), destToken);
      }

      return {
        alias: alias
      };
    };

    return {
      alias: alias
    };
  };

  _proto.middleware = function middleware(deps, _middleware) {
    if (_middleware === undefined) {
      _middleware = function _middleware() {
        return deps;
      };
    }

    this.register(createPlugin({
      deps: deps,
      middleware: _middleware
    }));
  };

  _proto.enhance = function enhance(token, enhancer) {
    token.stacks.push({
      type: 'enhance',
      stack: new Error().stack
    });

    var _ref2 = this.registered.get(getTokenRef(token)) || {
      aliases: new Map(),
      enhancers: [],
      value: undefined
    },
        value = _ref2.value,
        aliases = _ref2.aliases,
        enhancers = _ref2.enhancers;

    this.enhancerToToken.set(enhancer, token);

    if (enhancers && Array.isArray(enhancers)) {
      enhancers.push(enhancer);
    }

    this.registered.set(getTokenRef(token), {
      value: value,
      aliases: aliases,
      enhancers: enhancers,
      token: token
    });
  };

  _proto.cleanup = function cleanup() {
    return Promise.all(this.cleanups.map(function (fn) {
      return fn();
    }));
  };

  _proto.resolve = function resolve() {
    var _this3 = this;

    if (!this.renderer) {
      throw new Error('Missing registration for RenderToken');
    }

    this._register(RenderToken, this.renderer);

    var resolved = new Map(); // Token.ref || Token => Service

    var nonPluginTokens = new Set(); // Token

    var resolving = new Set(); // Token.ref || Token

    var registered = this.registered; // Token.ref || Token -> {value, aliases, enhancers}

    var resolvedPlugins = []; // Plugins

    var appliedEnhancers = [];

    var resolveToken = function resolveToken(token, tokenAliases) {
      // Base: if we have already resolved the type, return it
      if (tokenAliases && tokenAliases.has(getTokenRef(token))) {
        var newToken = tokenAliases.get(getTokenRef(token));

        if (newToken) {
          token = newToken;
        }
      }

      if (resolved.has(getTokenRef(token))) {
        return resolved.get(getTokenRef(token));
      } // Base: if currently resolving the same type, we have a circular dependency


      if (resolving.has(getTokenRef(token))) {
        throw new Error("Cannot resolve circular dependency: " + token.name);
      } // Base: the type was never registered, throw error or provide undefined if optional


      var _ref3 = registered.get(getTokenRef(token)) || {},
          value = _ref3.value,
          aliases = _ref3.aliases,
          enhancers = _ref3.enhancers;

      if (value === undefined) {
        // Early return if token is optional
        var isOptional = token instanceof TokenImpl && token.type === TokenType.Optional;

        if (isOptional && (!enhancers || !enhancers.length)) {
          return;
        }

        var dependents = Array.from(_this3.registered.entries());
        /**
         * Iterate over the entire list of dependencies and find all
         * dependencies of a given token.
         */

        var findDependentTokens = function findDependentTokens() {
          return dependents.filter(function (entry) {
            if (!entry[1].value || !entry[1].value.deps) {
              return false;
            }

            return Object.values(entry[1].value.deps).includes(token);
          }).map(function (entry) {
            return entry[1].token.name;
          });
        };

        var findDependentEnhancers = function findDependentEnhancers() {
          return appliedEnhancers.filter(function (_ref4) {
            var provides = _ref4[1];

            if (!provides || !provides.deps) {
              return false;
            }

            return Object.values(provides.deps).includes(token);
          }).map(function (_ref5) {
            var enhancer = _ref5[0];

            var enhancedToken = _this3.enhancerToToken.get(enhancer);

            return "EnhancerOf<" + (enhancedToken ? enhancedToken.name : '(unknown)') + ">";
          });
        };

        var dependentTokens = [].concat(findDependentTokens(), findDependentEnhancers());
        var base = 'A plugin depends on a token, but the token was not registered';
        var downstreams = 'This token is required by plugins registered with tokens: ' + dependentTokens.map(function (token) {
          return "\"" + token + "\"";
        }).join(', ');
        var stack = token.stacks.find(function (t) {
          return t.type === 'token';
        });
        var meta = "Required token: " + (token ? token.name : '') + "\n" + downstreams + "\n" + (stack ? stack.stack : '');
        var clue = 'Different tokens with the same name were detected:\n\n';
        var suggestions = token ? _this3.plugins.filter(function (p) {
          return p.name === token.name;
        }).map(function (p) {
          var stack = p.stacks.find(function (t) {
            return t.type === 'token';
          });
          return p.name + "\n" + (stack ? stack.stack : '') + "\n\n";
        }).join('\n\n') : '';
        var help = 'You may have multiple versions of the same plugin installed.\n' + 'Ensure that `yarn list [the-plugin]` results in one version, ' + 'and use a yarn resolution or merge package version in your lock file to consolidate versions.\n\n';
        throw new Error(base + "\n\n" + meta + "\n\n" + (suggestions && clue + suggestions + help));
      } // Recursive: get the registered type and resolve it


      resolving.add(getTokenRef(token));

      function resolvePlugin(plugin) {
        var registeredDeps = plugin && plugin.deps || {};
        var resolvedDeps = {};

        for (var key in registeredDeps) {
          var registeredToken = registeredDeps[key];
          resolvedDeps[key] = resolveToken(registeredToken, aliases);
        } // `provides` should be undefined if the plugin does not have a `provides` function


        var provides = plugin && plugin.provides ? plugin.provides(resolvedDeps) : undefined;

        if (plugin && plugin.middleware) {
          resolvedPlugins.push(plugin.middleware(resolvedDeps, provides));
        }

        return provides;
      }

      var provides = value;

      if (value && value.__plugin__) {
        provides = resolvePlugin(provides);

        if (value.cleanup) {
          _this3.cleanups.push(function () {
            return typeof value.cleanup === 'function' ? value.cleanup(provides) : Promise.resolve();
          });
        }
      } else {
        nonPluginTokens.add(token);
      }

      if (enhancers && enhancers.length) {
        enhancers.forEach(function (e) {
          var nextProvides = e(provides);
          appliedEnhancers.push([e, nextProvides]);

          if (nextProvides && nextProvides.__plugin__) {
            // if the token has a plugin enhancer, allow it to be registered with no dependents
            nonPluginTokens.delete(token);

            if (nextProvides.deps) {
              Object.values(nextProvides.deps).forEach(function (token) {
                return _this3._dependedOn.add(getTokenRef(token));
              });
            }

            nextProvides = resolvePlugin(nextProvides);
          }

          provides = nextProvides;
        });
      }

      resolved.set(getTokenRef(token), provides);
      resolving.delete(getTokenRef(token));
      return provides;
    };

    for (var i = 0; i < this.plugins.length; i++) {
      resolveToken(this.plugins[i]);
    }

    for (var _iterator = nonPluginTokens, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref6 = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref6 = _i.value;
      }

      var _token = _ref6;

      if (_token !== ElementToken && _token !== RenderToken && !this._dependedOn.has(getTokenRef(_token))) {
        throw new Error("Registered token without depending on it: \"" + _token.name + "\". See https://github.com/fusionjs/fusionjs/tree/master/fusion-core#registered-without-depending.");
      }
    }

    this.plugins = resolvedPlugins;

    this._getService = function (token) {
      return resolved.get(getTokenRef(token));
    };
  };

  _proto.getService = function getService(token) {
    if (!this._getService) {
      throw new Error('Cannot get service from unresolved app');
    }

    return this._getService(token);
  };

  return FusionApp;
}();
/* Helper functions */


function getTokenRef(token) {
  if (token instanceof TokenImpl) {
    return token.ref;
  }

  return token;
}

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// inline version of koa-compose to get around Rollup/CUP commonjs-related issue
function compose(middleware) {
  if (!Array.isArray(middleware)) {
    throw new TypeError('Middleware stack must be an array!');
  }

  for (var _iterator = middleware, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _fn = _ref;

    if (typeof _fn !== 'function') {
      throw new TypeError("Expected middleware function, received: " + _typeof(_fn));
    }
  }

  return function (context, next) {
    var index = -1;
    return dispatch(0);

    function dispatch(i) {
      if (i <= index) {
        return Promise.reject(new Error('next() called multiple times'));
      }

      index = i;
      var fn = middleware[i];
      if (i === middleware.length) fn = next;
      if (!fn) return Promise.resolve();

      try {
        return fn(context, function next() {
          return dispatch(i + 1);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    }
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Timing = function Timing() {
  this.start = now();
  this.render = deferred();
  this.end = deferred();
  this.downstream = deferred();
  this.upstream = deferred();
  this.upstreamStart = -1;
};

var timing = {
  from: memoize(function () {
    return new Timing();
  })
};
var TimingToken = createToken('TimingToken');

function _middleware(ctx, next) {
  ctx.memoized = new Map();

  var _timing$from = timing.from(ctx),
      start = _timing$from.start,
      render = _timing$from.render,
      end = _timing$from.end,
      downstream = _timing$from.downstream,
      upstream = _timing$from.upstream;

  ctx.timing = {
    start: start,
    render: render.promise,
    end: end.promise,
    downstream: downstream.promise,
    upstream: upstream.promise
  };
  return next().then(function () {
    var upstreamTime = now() - timing.from(ctx).upstreamStart;
    upstream.resolve(upstreamTime);
    var endTime = now() - ctx.timing.start;
    end.resolve(endTime);
  }).catch(function (e) {
    // currently we only resolve upstream and downstream when the request does not error
    // we should however always resolve the request end timing
    if (e && e.status) {
      // this ensures any logging / metrics based on ctx.status will recieve the correct status code
      ctx.status = e.status;
    }

    var endTime = now() - ctx.timing.start;
    end.resolve(endTime);
    throw e;
  });
}

var timing$1 = createPlugin({
  provides: function provides() {
    return timing;
  },
  middleware: function middleware() {
    return _middleware;
  }
});
function now() {
  {
    // eslint-disable-next-line cup/no-undef
    if (window.performance && window.performance.now) {
      // eslint-disable-next-line cup/no-undef
      return Math.round(window.performance.now());
    }

    return Date.now();
  }
}

function deferred() {
  var resolve = function resolve() {};

  var reject = function reject() {};

  var promise = new Promise(function (res, rej) {
    resolve = res;
    reject = rej;
  });
  return {
    promise: promise,
    resolve: resolve,
    reject: reject
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var getEnv = function () {};

 // Handle flow-types for export so browser export is ignored.

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
function createClientHydrate(_ref) {
  var element = _ref.element;
  return function clientHydrate(ctx, next) {
    ctx.prefix = window.__ROUTE_PREFIX__ || ''; // serialized by ./server

    ctx.element = element;
    ctx.preloadChunks = [];
    return next();
  };
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function createClientRenderer(_ref) {
  var render = _ref.render;
  return function renderer(ctx, next) {
    var rendered = render(ctx.element, ctx);

    if (rendered instanceof Promise) {
      return rendered.then(function (r) {
        ctx.rendered = r;
        return next();
      });
    } else {
      ctx.rendered = rendered;
      return next();
    }
  };
}

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
function clientApp () {
  return (
    /*#__PURE__*/
    function (_BaseApp) {
      _inheritsLoose$1(ClientApp, _BaseApp);

      function ClientApp(el, render) {
        var _this;

        _this = _BaseApp.call(this, el, render) || this;

        _this.register(TimingToken, timing$1);

        _this.middleware({
          element: ElementToken
        }, createClientHydrate);

        return _this;
      }

      var _proto = ClientApp.prototype;

      _proto.resolve = function resolve() {
        this.middleware({
          render: RenderToken
        }, createClientRenderer);
        return _BaseApp.prototype.resolve.call(this);
      };

      _proto.callback = function callback() {
        this.resolve();
        var middleware = compose(this.plugins);
        return function () {
          // TODO(#62): Create noop context object to match server api
          var ctx = {
            url: window.location.pathname + window.location.search,
            element: null,
            body: null
          };
          return middleware(ctx, function () {
            return Promise.resolve();
          }).then(function () {
            return ctx;
          });
        };
      };

      return ClientApp;
    }(FusionApp)
  );
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function assetUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}
function chunkId(filename) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return filename;
}
function syncChunkIds(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function syncChunkPaths(argument) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return argument;
}
function workerUrl(url) {
  /**
   * PLEASE NOTE: a build step transforms
   * the arguments provided to this function
   */
  return url;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var index = clientApp();

export default index;
export { getEnv, compose, memoize, flowHtml as html, flowDangerouslySetHTML as dangerouslySetHTML, flowConsumeSanitizedHTML as consumeSanitizedHTML, flowEscape as escape, unescape, assetUrl, chunkId, syncChunkIds, syncChunkPaths, workerUrl, RenderToken, ElementToken, SSRDeciderToken, HttpServerToken, SSRBodyTemplateToken, RoutePrefixToken, CriticalChunkIdsToken, RouteTagsToken, createPlugin, createToken };
