import { createElement, Component, Children } from 'react';
import PropTypes from 'prop-types';
import { __RouterContext, Router, Route, BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Switch, matchPath, withRouter, useHistory, useParams, useRouteMatch, useLocation } from 'react-router-dom';
import { createBrowserHistory } from 'history';
import { UniversalEventsToken } from 'fusion-plugin-universal-events';
import { createPlugin, createToken, unescape, memoize, RouteTagsToken } from 'fusion-core';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Status =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(Status, _React$Component);

  function Status(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var _context$router = context.router;
    _context$router = _context$router === void 0 ? {} : _context$router;
    var staticContext = _context$router.staticContext;

    if (staticContext && staticContext.setCode) {
      staticContext.setCode(parseInt(_this.props.code, 10));
    }

    return _this;
  }

  var _proto = Status.prototype;

  _proto.render = function render() {
    return this.props.children;
  };

  return Status;
}(Component);
Status.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
};
var NotFound = function NotFound(props) {
  return createElement(Status, {
    code: 404
  }, props.children);
};

function _inheritsLoose$1(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Lifecycle =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$1(Lifecycle, _React$Component);

  function Lifecycle(props) {
    var _this;

    _this = _React$Component.call(this, props) || this;
    if (_this.props.onConstruct) _this.props.onConstruct.call(_this, _this);
    return _this;
  }

  var _proto = Lifecycle.prototype;

  _proto.componentDidMount = function componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  };

  _proto.render = function render() {
    return null;
  };

  return Lifecycle;
}(Component);

var Redirect =
/*#__PURE__*/
function (_React$Component2) {
  _inheritsLoose$1(Redirect, _React$Component2);

  function Redirect() {
    return _React$Component2.apply(this, arguments) || this;
  }

  var _proto2 = Redirect.prototype;

  _proto2.isStatic = function isStatic(context) {
    if (context === void 0) {
      context = this.context;
    }

    return !!(context && context.router && context.router.staticContext);
  };

  _proto2.perform = function perform(history, staticContext) {
    var _this$props = this.props,
        push = _this$props.push,
        to = _this$props.to,
        code = _this$props.code;

    if (push) {
      history.push(to);
    } else {
      history.replace(to);
    }
  };

  _proto2.render = function render() {
    var _this2 = this;

    return createElement(__RouterContext.Consumer, null, function (context) {
      var history = context.history;
      var staticContext = _this2.context.router && _this2.context.router.staticContext;

      var perform = function perform() {
        return _this2.perform(history, staticContext);
      };

      var props = _this2.isStatic() ? {
        onConstruct: perform
      } : {
        onMount: perform
      };
      return createElement(Lifecycle, props);
    });
  };

  return Redirect;
}(Component);
Redirect.defaultProps = {
  push: false,
  code: 307
};
Redirect.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
}; // Sanity type checking

function _inheritsLoose$2(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */
var ServerRouter =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$2(ServerRouter, _React$Component);

  function ServerRouter() {
    return _React$Component.apply(this, arguments) || this;
  }

  var _proto = ServerRouter.prototype;

  _proto.getChildContext = function getChildContext() {
    var _this = this;

    return {
      router: {
        staticContext: this.props.context || {}
      },
      onRoute: function onRoute(routeData) {
        return _this.props.onRoute && _this.props.onRoute(routeData);
      }
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Provider = _this$props.Provider,
        history = _this$props.history,
        basename = _this$props.basename,
        children = _this$props.children;
    if (!Provider) throw new Error('Missing Provider for Server Router');
    return (// $FlowFixMe
      createElement(Provider, {
        basename: basename,
        history: history
      }, children)
    );
  };

  return ServerRouter;
}(Component);

ServerRouter.defaultProps = {
  basename: '',
  context: {},
  Provider: Router,
  onRoute: function onRoute() {}
};
ServerRouter.childContextTypes = {
  router: function router() {},
  onRoute: function onRoute() {}
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var ReactRouterRoute = Route;

var isEmptyChildren = function isEmptyChildren(children) {
  return Children.count(children) === 0;
};

function Route$1(props, context) {
  var trackingId = props.trackingId,
      component = props.component,
      render = props.render,
      _children = props.children,
      remainingProps = _objectWithoutProperties(props, ["trackingId", "component", "render", "children"]);

  return createElement(ReactRouterRoute, _extends({}, remainingProps, {
    // eslint-disable-next-line react/no-children-prop
    children: function children(routeProps) {
      var match = routeProps.match;

      if (match && match.isExact) {
        if (typeof context.onRoute === 'function') {
          context.onRoute({
            page: match.path,
            title: trackingId || match.path,
            params: match.params
          });
        }
      }

      if (component) return match ? createElement(component, routeProps) : null;
      if (render) return match ? render(routeProps) : null;
      if (typeof _children === 'function') return _children(routeProps);
      if (_children && !isEmptyChildren(_children)) return Children.only(_children);
      return null;
    }
  }));
}

Route$1.contextTypes = {
  onRoute: PropTypes.func
};
Route$1.displayName = 'FusionRoute';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function _inheritsLoose$3(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var BrowserRouter$2 =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose$3(BrowserRouter$$1, _React$Component);

  function BrowserRouter$$1(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    _this.lastTitle = null;
    return _this;
  }

  var _proto = BrowserRouter$$1.prototype;

  _proto.getChildContext = function getChildContext() {
    var _this2 = this;

    var __IS_PREPARE__ = this.context.__IS_PREPARE__;
    return {
      onRoute: function onRoute(routeData) {
        if (routeData.title !== _this2.lastTitle && !__IS_PREPARE__) {
          _this2.lastTitle = routeData.title;
          _this2.props.onRoute && _this2.props.onRoute(routeData);
        }
      }
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Provider = _this$props.Provider,
        history = _this$props.history,
        basename = _this$props.basename;
    if (!Provider) throw new Error('Missing Provider for Browser Router');
    return (// $FlowFixMe
      createElement(Provider, {
        basename: basename,
        history: history
      }, this.props.children)
    );
  };

  return BrowserRouter$$1;
}(Component);

BrowserRouter$2.defaultProps = {
  onRoute: function onRoute() {},
  Provider: Router
};
BrowserRouter$2.propTypes = {
  children: PropTypes.node,
  onRoute: PropTypes.func,
  history: PropTypes.object,
  Provider: PropTypes.any,
  basename: PropTypes.string
};
BrowserRouter$2.contextTypes = {
  __IS_PREPARE__: PropTypes.bool
};
BrowserRouter$2.childContextTypes = {
  onRoute: PropTypes.func.isRequired
};
var BrowserRouterTyped = BrowserRouter$2;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
/**
 * Cast each of these imports from react-router-dom to a copied-version of their
 * types.  This is necessary as the libdef defined types will not be accessible to
 * consumers of this package.
 */
var BrowserRouter$3 = BrowserRouter;
var HashRouter$2 = HashRouter;
var Link$2 = Link;
var MemoryRouter$2 = MemoryRouter;
var NavLink$2 = NavLink;
var Prompt$2 = Prompt;
var Switch$2 = Switch;
var matchPath$2 = matchPath;
var withRouter$2 = withRouter;
var useHistory$2 = useHistory;
var useRouteMatch$2 = useRouteMatch;
var useLocation$2 = useLocation;
var useParams$2 = useParams;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var _templateObject = /*#__PURE__*/ _taggedTemplateLiteralLoose(["\n              <script id=\"__ROUTER_DATA__\" type=\"application/json\">\n                ", "\n              </script>\n            "], ["\n              <script id=\"__ROUTER_DATA__\" type=\"application/json\">\n                ", "\n              </script>\n            "]);

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _taggedTemplateLiteralLoose(strings, raw) { if (!raw) { raw = strings.slice(0); } strings.raw = raw; return strings; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var RouterProviderToken = createToken('RouterProvider');
var RouterToken = createToken('Router');
var Router$1 = BrowserRouterTyped;
// Preserve browser history instance across HMR
var browserHistory;
var plugin = createPlugin({
  deps: {
    emitter: UniversalEventsToken.optional,
    Provider: RouterProviderToken.optional,
    RouteTags: RouteTagsToken
  },
  middleware: function middleware(_ref, self) {
    var RouteTags = _ref.RouteTags,
        emitter = _ref.emitter,
        _ref$Provider = _ref.Provider,
        Provider = _ref$Provider === void 0 ? Router : _ref$Provider;
    return function (ctx, next) {
      return new Promise(function ($return, $error) {
        var tags = RouteTags.from(ctx);
        var prefix = ctx.prefix || '';

        if (!ctx.element) {
          return $return(next());
        }

        var myAPI = self.from(ctx);

        {
          // TODO(#3): We should consider adding render/downstream/upstream timings for the browser
          var _pageData = {};
          var element = document.getElementById('__ROUTER_DATA__');

          if (element) {
            _pageData = JSON.parse(unescape(element.textContent));
            tags.name = _pageData.title;
            tags.page = _pageData.page;
          }

          emitter && emitter.map(function (payload) {
            if (payload && _typeof(payload) === 'object') {
              payload.__url__ = _pageData.title;
              payload.__urlParams__ = _pageData.params;
            }

            return payload;
          }); // preserving browser history across hmr fixes warning "Warning: You cannot change <Router history>"
          // we don't want to preserve the `browserHistory` instance across jsdom tests however, as it will cause
          // routes to match based on the previous location information.

          if (!browserHistory || process.env.NODE_ENV !== "production" && typeof window.jsdom !== 'undefined') {
            browserHistory = createBrowserHistory({
              basename: ctx.prefix
            });
          } // Expose the history object


          myAPI.history = browserHistory;
          ctx.element = createElement(Router$1, {
            history: browserHistory,
            Provider: Provider,
            basename: ctx.prefix,
            onRoute: function onRoute(payload) {
              _pageData = payload;
              tags.name = _pageData.title;
              tags.page = _pageData.page;
              emitter && emitter.emit('pageview:browser', payload);
            }
          }, ctx.element);
          return $return(next());
        }

        return $return();
      });
    };
  },
  provides: function provides() {
    return {
      from: memoize(function () {
        var api = {
          history: null
        };
        return api;
      })
    };
  }
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* Custom types */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var BrowserRouter$4 = BrowserRouter$3;
var HashRouter$3 = HashRouter$2;
var Link$3 = Link$2;
var matchPath$3 = matchPath$2;
var MemoryRouter$3 = MemoryRouter$2;
var NavLink$3 = NavLink$2;
var Prompt$3 = Prompt$2;
var Route$2 = Route$1;
var Router$2 = BrowserRouterTyped;
var Switch$3 = Switch$2;
var withRouter$3 = withRouter$2;
var NotFound$1 = NotFound;
var Redirect$1 = Redirect;
var Status$1 = Status;
var useHistory$3 = useHistory$2;
var useRouteMatch$3 = useRouteMatch$2;
var useLocation$3 = useLocation$2;
var useParams$3 = useParams$2;

export default plugin;
export { BrowserRouter$4 as BrowserRouter, HashRouter$3 as HashRouter, Link$3 as Link, matchPath$3 as matchPath, MemoryRouter$3 as MemoryRouter, NavLink$3 as NavLink, NotFound$1 as NotFound, Prompt$3 as Prompt, Redirect$1 as Redirect, Route$2 as Route, Router$2 as Router, Status$1 as Status, Switch$3 as Switch, withRouter$3 as withRouter, RouterProviderToken, RouterToken, useHistory$3 as useHistory, useRouteMatch$3 as useRouteMatch, useLocation$3 as useLocation, useParams$3 as useParams };
