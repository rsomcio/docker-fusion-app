'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var PropTypes = _interopDefault(require('prop-types'));
var reactRouterDom = require('react-router-dom');
var history = require('history');
var fusionPluginUniversalEvents = require('fusion-plugin-universal-events');
var fusionCore = require('fusion-core');

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Status extends React.Component {
  constructor(props, context) {
    super(props, context);
    const {
      router: {
        staticContext
      } = {}
    } = context;

    if (staticContext && staticContext.setCode) {
      staticContext.setCode(parseInt(this.props.code, 10));
    }
  }

  render() {
    return this.props.children;
  }

}
Status.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
};
const NotFound = props => React.createElement(Status, {
  code: 404
}, props.children);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class Lifecycle extends React.Component {
  constructor(props) {
    super(props);
    if (this.props.onConstruct) this.props.onConstruct.call(this, this);
  }

  componentDidMount() {
    if (this.props.onMount) this.props.onMount.call(this, this);
  }

  render() {
    return null;
  }

}

class Redirect extends React.Component {
  isStatic(context = this.context) {
    return !!(context && context.router && context.router.staticContext);
  }

  perform(history$$1, staticContext) {
    const {
      push,
      to,
      code
    } = this.props;

    if (true && staticContext) {
      staticContext.setCode(parseInt(code, 10));
      staticContext.redirect(to);
      return;
    }

    if (push) {
      history$$1.push(to);
    } else {
      history$$1.replace(to);
    }
  }

  render() {
    return React.createElement(reactRouterDom.__RouterContext.Consumer, null, context => {
      const history$$1 = context.history;
      const staticContext = this.context.router && this.context.router.staticContext;

      const perform = () => this.perform(history$$1, staticContext);

      const props = this.isStatic() ? {
        onConstruct: perform
      } : {
        onMount: perform
      };
      return React.createElement(Lifecycle, props);
    });
  }

}
Redirect.defaultProps = {
  push: false,
  code: 307
};
Redirect.contextTypes = {
  router: PropTypes.shape({
    staticContext: PropTypes.object
  })
}; // Sanity type checking

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
/**
 * The public top-level API for a "static" <Router>, so-called because it
 * can't actually change the current location. Instead, it just records
 * location changes in a context object. Useful mainly in testing and
 * server-rendering scenarios.
 */
class ServerRouter extends React.Component {
  getChildContext() {
    return {
      router: {
        staticContext: this.props.context || {}
      },
      onRoute: routeData => this.props.onRoute && this.props.onRoute(routeData)
    };
  }

  render() {
    const {
      Provider,
      history: history$$1,
      basename,
      children
    } = this.props;
    if (!Provider) throw new Error('Missing Provider for Server Router');
    return (// $FlowFixMe
      React.createElement(Provider, {
        basename: basename,
        history: history$$1
      }, children)
    );
  }

}

ServerRouter.defaultProps = {
  basename: '',
  context: {},
  Provider: reactRouterDom.Router,
  onRoute: () => {}
};
ServerRouter.childContextTypes = {
  router: () => {},
  onRoute: () => {}
};
const ServerRouterTyped = ServerRouter;

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const ReactRouterRoute = reactRouterDom.Route;

const isEmptyChildren = children => React.Children.count(children) === 0;

function Route(props, context) {
  const {
    trackingId,
    component,
    render,
    children
  } = props,
        remainingProps = _objectWithoutProperties(props, ["trackingId", "component", "render", "children"]);

  return React.createElement(ReactRouterRoute, _extends({}, remainingProps, {
    // eslint-disable-next-line react/no-children-prop
    children: routeProps => {
      const {
        match
      } = routeProps;

      if (match && match.isExact) {
        if (typeof context.onRoute === 'function') {
          context.onRoute({
            page: match.path,
            title: trackingId || match.path,
            params: match.params
          });
        }
      }

      if (component) return match ? React.createElement(component, routeProps) : null;
      if (render) return match ? render(routeProps) : null;
      if (typeof children === 'function') return children(routeProps);
      if (children && !isEmptyChildren(children)) return React.Children.only(children);
      return null;
    }
  }));
}

Route.contextTypes = {
  onRoute: PropTypes.func
};
Route.displayName = 'FusionRoute';

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
/**
 * Cast each of these imports from react-router-dom to a copied-version of their
 * types.  This is necessary as the libdef defined types will not be accessible to
 * consumers of this package.
 */
const BrowserRouter = reactRouterDom.BrowserRouter;
const HashRouter = reactRouterDom.HashRouter;
const Link = reactRouterDom.Link;
const MemoryRouter = reactRouterDom.MemoryRouter;
const NavLink = reactRouterDom.NavLink;
const Prompt = reactRouterDom.Prompt;
const Switch = reactRouterDom.Switch;
const matchPath = reactRouterDom.matchPath;
const withRouter = reactRouterDom.withRouter;
const useHistory = reactRouterDom.useHistory;
const useRouteMatch = reactRouterDom.useRouteMatch;
const useLocation = reactRouterDom.useLocation;
const useParams = reactRouterDom.useParams;

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class BrowserRouter$1 extends React.Component {
  constructor(props, context) {
    super(props, context);
    this.lastTitle = null;
  }

  getChildContext() {
    const {
      __IS_PREPARE__
    } = this.context;
    return {
      onRoute: routeData => {
        if (routeData.title !== this.lastTitle && !__IS_PREPARE__) {
          this.lastTitle = routeData.title;
          this.props.onRoute && this.props.onRoute(routeData);
        }
      }
    };
  }

  render() {
    const {
      Provider,
      history: history$$1,
      basename
    } = this.props;
    if (!Provider) throw new Error('Missing Provider for Browser Router');
    return (// $FlowFixMe
      React.createElement(Provider, {
        basename: basename,
        history: history$$1
      }, this.props.children)
    );
  }

}

BrowserRouter$1.defaultProps = {
  onRoute: () => {},
  Provider: reactRouterDom.Router
};
BrowserRouter$1.propTypes = {
  children: PropTypes.node,
  onRoute: PropTypes.func,
  history: PropTypes.object,
  Provider: PropTypes.any,
  basename: PropTypes.string
};
BrowserRouter$1.contextTypes = {
  __IS_PREPARE__: PropTypes.bool
};
BrowserRouter$1.childContextTypes = {
  onRoute: PropTypes.func.isRequired
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const addLeadingSlash = path => path.charAt(0) === '/' ? path : '/' + path;

const addRoutePrefix = (location, prefix) => {
  if (!prefix) return location;

  if (typeof location === 'string') {
    return `${prefix}${addLeadingSlash(location)}`;
  } else {
    return _objectSpread({}, location, {
      pathname: `${prefix}${addLeadingSlash(location.pathname)}`
    });
  }
};
const removeRoutePrefix = (location, prefix) => {
  if (!prefix) return location;
  const pathname = typeof location === 'string' ? location : location.pathname;
  const hasPrefix = (pathname + '/').indexOf(prefix + '/') === 0;
  const unprefixedPathname = pathname.slice(prefix.length);
  const relativePathname = hasPrefix ? unprefixedPathname : pathname;

  if (typeof location === 'string') {
    return relativePathname;
  } else {
    return _objectSpread({}, location, {
      pathname: relativePathname
    });
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const createLocation = (path, prefix) => {
  const unprefixed = removeRoutePrefix(path, prefix);

  if (typeof unprefixed === 'string') {
    return history.parsePath(unprefixed);
  } else {
    return unprefixed;
  }
};

const createPrefixedURL = (location, prefix) => {
  const prefixed = addRoutePrefix(location, prefix);

  if (typeof prefixed === 'string') {
    return prefixed;
  } else {
    return history.createPath(prefixed);
  }
};

const createURL = (location, prefix) => {
  const unprefixed = removeRoutePrefix(location, prefix);

  if (typeof unprefixed === 'string') {
    return unprefixed;
  } else {
    return history.createPath(unprefixed);
  }
};

const staticHandler = methodName => () => {
  throw new Error(`You cannot ${methodName} with server side <Router>`);
};

const noop = () => {};

function createServerHistory(basename, context, location) {
  function createHref(location) {
    return createPrefixedURL(location, basename);
  }

  function push(path) {
    context.action = 'PUSH';
    context.location = createLocation(path, basename);
    const url = createURL(path, basename);

    if (typeof url === 'string') {
      context.url = url;
    }
  }

  function replace(path) {
    context.action = 'REPLACE';
    context.location = createLocation(path, basename);
    const url = createURL(path, basename);

    if (typeof url === 'string') {
      context.url = url;
    }
  }

  const history$$1 = {
    length: 0,
    createHref,
    action: 'POP',
    location: createLocation(location, basename),
    push,
    replace,
    go: staticHandler('go'),
    goBack: staticHandler('back'),
    goForward: staticHandler('forward'),
    listen: () => noop
  };
  return history$$1;
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const RouterProviderToken = fusionCore.createToken('RouterProvider');
const RouterToken = fusionCore.createToken('Router');
const Router$$1 = ServerRouterTyped;
const plugin = fusionCore.createPlugin({
  deps: {
    emitter: fusionPluginUniversalEvents.UniversalEventsToken.optional,
    Provider: RouterProviderToken.optional,
    RouteTags: fusionCore.RouteTagsToken
  },
  middleware: ({
    RouteTags,
    emitter,
    Provider = reactRouterDom.Router
  }, self) => {
    return async (ctx, next) => {
      const tags = RouteTags.from(ctx);
      const prefix = ctx.prefix || '';

      if (!ctx.element) {
        return next();
      }

      const myAPI = self.from(ctx);

      {
        let pageData = {
          title: ctx.path,
          page: ctx.path
        };
        const context = {
          action: null,
          location: null,
          url: null,
          setCode: code => {
            ctx.status = code;
          },
          redirect: url => {
            const toUrl = addRoutePrefix(url, prefix);

            if (typeof toUrl === 'string') {
              ctx.redirect(toUrl);
            }
          }
        }; // Expose the history object

        const history$$1 = createServerHistory(prefix, context, prefix + ctx.url);
        myAPI.history = history$$1;
        ctx.element = React.createElement(Router$$1, {
          history: history$$1,
          Provider: Provider,
          onRoute: d => {
            pageData = d;
            tags.name = pageData.title;
            tags.page = pageData.page;
          },
          basename: prefix,
          context: context
        }, ctx.element);
        return next().then(() => {
          ctx.template.body.push(fusionCore.html`
              <script id="__ROUTER_DATA__" type="application/json">
                ${JSON.stringify(pageData)}
              </script>
            `);

          if (emitter) {
            const scopedEmitter = emitter.from(ctx);

            const emitTiming = type => timing => {
              scopedEmitter.emit(type, {
                title: pageData.title,
                page: pageData.page,
                status: ctx.status,
                timing
              });
            };

            scopedEmitter.map(payload => {
              if (payload && typeof payload === 'object') {
                payload.__url__ = pageData.title;
              }

              return payload;
            });
            ctx.timing.end.then(timing => {
              emitTiming('pageview:server')(timing);
              ctx.timing.render.then(emitTiming('render:server'));
            });
          }
        });
      }
    };
  },

  provides() {
    return {
      from: fusionCore.memoize(() => {
        const api = {
          history: null
        };
        return api;
      })
    };
  }

});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* Custom types */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const BrowserRouter$3 = BrowserRouter;
const HashRouter$2 = HashRouter;
const Link$2 = Link;
const matchPath$2 = matchPath;
const MemoryRouter$2 = MemoryRouter;
const NavLink$2 = NavLink;
const Prompt$2 = Prompt;
const Route$1 = Route;
const Router$1 = ServerRouterTyped;
const Switch$2 = Switch;
const withRouter$2 = withRouter;
const NotFound$1 = NotFound;
const Redirect$1 = Redirect;
const Status$1 = Status;
const useHistory$2 = useHistory;
const useRouteMatch$2 = useRouteMatch;
const useLocation$2 = useLocation;
const useParams$2 = useParams;

exports.default = plugin;
exports.BrowserRouter = BrowserRouter$3;
exports.HashRouter = HashRouter$2;
exports.Link = Link$2;
exports.matchPath = matchPath$2;
exports.MemoryRouter = MemoryRouter$2;
exports.NavLink = NavLink$2;
exports.NotFound = NotFound$1;
exports.Prompt = Prompt$2;
exports.Redirect = Redirect$1;
exports.Route = Route$1;
exports.Router = Router$1;
exports.Status = Status$1;
exports.Switch = Switch$2;
exports.withRouter = withRouter$2;
exports.RouterProviderToken = RouterProviderToken;
exports.RouterToken = RouterToken;
exports.useHistory = useHistory$2;
exports.useRouteMatch = useRouteMatch$2;
exports.useLocation = useLocation$2;
exports.useParams = useParams$2;
