'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var ssrPrepass = _interopDefault(require('@rtsao/react-ssr-prepass'));
var PropTypes = _interopDefault(require('prop-types'));
var server = require('react-dom/server');
var FusionApp = require('fusion-core');
var FusionApp__default = _interopDefault(FusionApp);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class PrepareState {
  constructor() {
    this.seen = new Map();
    this.pending = new Map();
  }

  isResolved(Component, effectId, effectPromiseThunk) {
    let seenEffectIds = this.seen.get(Component);
    let pendingPromises = this.pending.get(Component); // Initialize if not present

    if (!seenEffectIds) {
      seenEffectIds = new Set();
      this.seen.set(Component, seenEffectIds);
    } // If seen and not pending, then it has been resolved


    if (seenEffectIds.has(effectId) && (!pendingPromises || !pendingPromises.has(effectId))) {
      return true;
    } // If not yet seen, need to start promise


    if (!seenEffectIds.has(effectId)) {
      if (!pendingPromises) {
        pendingPromises = new Map();
        this.pending.set(Component, pendingPromises);
      }

      const effectPromise = effectPromiseThunk();
      seenEffectIds.add(effectId);
      pendingPromises.set(effectId, effectPromise);
    }

    return false;
  }

  consumeAndAwaitPromises() {
    let promises = [];

    for (let map of this.pending.values()) {
      for (let promise of map.values()) {
        promises.push(promise);
      }
    }

    this.pending = new Map(); // clear

    return Promise.all(promises);
  }

}

function prepare(element) {
  const prepareState = new PrepareState();

  class PrepareContextProvider extends React.Component {
    getChildContext() {
      return {
        __IS_PREPARE__: true,
        __PREPARE_STATE__: prepareState
      };
    }

    render() {
      return element;
    }

  }

  PrepareContextProvider.childContextTypes = {
    __PREPARE_STATE__: () => {},
    __IS_PREPARE__: () => {}
  };

  async function process() {
    await ssrPrepass(React.createElement(PrepareContextProvider));

    if (prepareState.pending.size) {
      return prepareState.consumeAndAwaitPromises().then(process);
    }
  }

  return Promise.resolve().then(process);
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const prepared = (sideEffect, opts = {}) => OriginalComponent => {
  opts = Object.assign({
    boundary: false,
    defer: false,
    componentDidMount: true,
    componentWillReceiveProps: false,
    componentDidUpdate: false,
    contextTypes: {},
    forceUpdate: false
  }, opts);

  class PreparedComponent extends React.Component {
    componentDidMount() {
      if (opts.componentDidMount) {
        Promise.resolve(sideEffect(this.props, this.context)).then(() => {
          if (opts.forceUpdate) {
            this.forceUpdate();
          }
        });
      }
    }

    UNSAFE_componentWillReceiveProps(nextProps, nextContext) {
      if (opts.componentWillReceiveProps) {
        sideEffect(nextProps, nextContext);
      }
    }

    componentDidUpdate() {
      if (opts.componentDidUpdate) {
        sideEffect(this.props, this.context);
      }
    }

    render() {
      const effectId = this.props.effectId || 'defaultId';
      const prepareState = this.context.__PREPARE_STATE__;

      if (prepareState) {
        if (opts.defer || opts.boundary) {
          // skip prepare if defer or boundary
          return null;
        }

        const isResolved = prepareState.isResolved(PreparedComponent, effectId, () => sideEffect(this.props, this.context));

        if (!isResolved) {
          // Wait until resolved
          return null;
        }
      }

      return React.createElement(OriginalComponent, this.props);
    }

  }

  PreparedComponent.contextTypes = _objectSpread({
    __PREPARE_STATE__: () => {}
  }, opts.contextTypes);
  const displayName = OriginalComponent.displayName || OriginalComponent.name || '';
  PreparedComponent.displayName = `PreparedComponent(${displayName})`;
  return PreparedComponent;
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const contextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired
};

{
  // $FlowFixMe
  contextTypes.markAsCritical = PropTypes.func;
}

function withAsyncComponent({
  defer,
  load,
  LoadingComponent,
  ErrorComponent
}) {
  let AsyncComponent = null;
  let error = null;
  const metadata = {
    chunkIds: [],
    i18nKeys: []
  };

  function WithAsyncComponent(props) {
    if (error) {
      return React.createElement(ErrorComponent, {
        error: error
      });
    }

    if (!AsyncComponent) {
      return React.createElement(LoadingComponent, null);
    }

    return React.createElement(AsyncComponent, props);
  }

  return prepared((props, context) => {
    if (AsyncComponent) {
      if (true && context.markAsCritical) {
        metadata.chunkIds.forEach(chunkId => {
          context.markAsCritical(chunkId);
        });
      }

      return Promise.resolve(AsyncComponent);
    }

    let componentPromise;

    try {
      componentPromise = load();
    } catch (e) {
      componentPromise = Promise.reject(e);
    } // $FlowFixMe


    metadata.chunkIds = componentPromise.__CHUNK_IDS || []; // $FlowFixMe

    metadata.i18nKeys = componentPromise.__I18N_KEYS || [];

    if (true && context.markAsCritical) {
      metadata.chunkIds.forEach(chunkId => {
        context.markAsCritical(chunkId);
      });
    }

    const loadPromises = [componentPromise, ...context.splitComponentLoaders.map(loader => loader(metadata.chunkIds, metadata))];
    return Promise.all(loadPromises).then(([asyncComponent]) => {
      // Note: .default is toolchain specific, breaks w/ CommonJS exports
      AsyncComponent = asyncComponent.default;

      if (AsyncComponent === undefined) {
        throw new Error('Bundle does not contain a default export');
      }
    }).catch(err => {
      error = err;
       // log error
    });
  }, {
    defer,
    contextTypes,
    forceUpdate: true
  })(WithAsyncComponent);
}

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// to visit the minimum number of nodes

var traverseExclude = prepared(() => Promise.resolve(), {
  componentDidMount: false,
  componentWillReceiveProps: false,
  componentDidUpdate: false,
  defer: true
});

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
class PrepareProvider extends React.Component {
  constructor(props, context) {
    super(props, context);
    this.splitComponentLoaders = [];
    this.markAsCritical = props.markAsCritical;
  }

  getChildContext() {
    return {
      splitComponentLoaders: this.splitComponentLoaders,
      markAsCritical: this.markAsCritical
    };
  }

  render() {
    return React.Children.only(this.props.children);
  }

}

PrepareProvider.childContextTypes = {
  splitComponentLoaders: PropTypes.array.isRequired,
  markAsCritical: PropTypes.func
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const middleware = function (ctx, next) {
  if (process.env.NODE_ENV !== "production") {
    // eslint-disable-next-line no-console
    console.warn('The {middleware} export from fusion-react is deprecated.');
  }

  if (true && !ctx.element) {
    return next();
  }

  const markAsCritical = chunkId => {
    // Push to legacy context for backwards compat w/ legacy SSR template
    ctx.preloadChunks.push(chunkId);
  };
  ctx.element = React.createElement(PrepareProvider, {
    markAsCritical: markAsCritical
  }, ctx.element);
  return next();
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env node */
var serverRender = (el => `<div id='root'>${server.renderToString(el)}</div>`);

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var Provider = {
  create: name => {
    class Provider extends React.Component {
      getChildContext() {
        return {
          [name]: this.props.provides
        };
      }

      render() {
        return React.Children.only(this.props.children);
      }

    }

    Provider.childContextTypes = _objectSpread$1({}, Provider.childContextTypes || {}, {
      [name]: PropTypes.any.isRequired
    });
    Provider.displayName = name.replace(/^./, c => c.toUpperCase()) + 'Provider';
    return Provider;
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var plugin = {
  create: (name, plugin, provider) => {
    if (plugin.__plugin__ === undefined) {
      plugin = FusionApp.createPlugin(plugin);
    }

    if (!plugin.__plugin__) {
      throw new Error('Provided plugin does not match FusionPlugin<TDeps, TService>');
    }

    let originalMiddleware = plugin.middleware;
    const ProviderComponent = provider || Provider.create(name);

    plugin.middleware = (deps, provides) => {
      let nextMiddleware = originalMiddleware && originalMiddleware(deps, provides);

      const mw = function (ctx, next) {
        if (ctx.element) {
          ctx.element = React.createElement(ProviderComponent, {
            provides,
            ctx
          }, ctx.element);
        }

        if (nextMiddleware) {
          return nextMiddleware(ctx, next);
        }

        return next();
      };

      return mw;
    };

    return plugin;
  }
};

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/** Copyright (c) 2019 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
const FusionContext = React.createContext({});
const ServiceContext = React.createContext(() => {
  throw new Error('`ServiceContext.Provider` was not found. This occurs if you are attempting to use `ServiceContext` in a non-React Fusion.js application.');
});
function useService(token) {
  const getService = React.useContext(ServiceContext);
  const provides = getService(token);
  return provides;
}
function ServiceConsumer({
  token,
  children
}) {
  return React.createElement(ServiceContext.Consumer, null, getService => {
    const provides = getService(token);
    return children(provides);
  });
}

function getServices(getService, deps) {
  const services = {};
  Object.keys(deps).forEach(name => {
    services[name] = getService(deps[name]);
  });
  return services;
}

const identity = i => i;

function withServices(deps, mapServicesToProps = identity) {
  function resolve(getService) {
    const services = getServices(getService, deps);
    const serviceProps = mapServicesToProps(services);
    return serviceProps;
  }

  return Component => {
    return function WithServices(props) {
      return React.createElement(ServiceContext.Consumer, null, getService => React.createElement(Component, _extends({}, resolve(getService), props)));
    };
  };
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function capitalize(str) {
  return str.replace(/^./, c => c.toUpperCase());
}

var hoc = {
  create: (name, mapProvidesToProps, token) => {
    const mapProvides = mapProvidesToProps ? mapProvidesToProps : provides => ({
      [name]: provides
    });
    const _token = token; // Make token constant for flow

    if (_token) {
      // Use new Context through useService hook
      return Component => {
        const Wrapper = props => {
          const service = useService(_token);
          return React.createElement(Component, _objectSpread$2({}, props, {}, mapProvides(service)));
        };

        const displayName = Component.displayName || Component.name || 'Anonymous';
        Wrapper.displayName = `With${capitalize(name)}(${displayName})`;
        return Wrapper;
      };
    } else {
      // Use legacy Context
      return Component => {
        class HOC extends React.Component {
          constructor(props, ctx) {
            super(props, ctx);
            this.provides = ctx[name];
          }

          render() {
            const props = _objectSpread$2({}, this.props, {}, mapProvides(this.provides));

            return React.createElement(Component, props);
          }

        }

        const displayName = Component.displayName || Component.name || 'Anonymous';
        HOC.displayName = `With${capitalize(name)}(${displayName})`;
        HOC.contextTypes = {
          [name]: PropTypes.any.isRequired
        };
        return HOC;
      };
    }
  }
};

/** Copyright (c) 2018 Uber Technologies, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/* eslint-env browser */
const SkipPrepareToken = FusionApp.createToken('SkipPrepareToken');
class App extends FusionApp__default {
  constructor(root, render) {
    if (!React.isValidElement(root)) {
      throw new Error('Invalid React element. Ensure your root element is a React.Element (e.g. <Foo />) and not a React.Component (e.g. Foo)');
    }

    const getService = token => {
      // $FlowFixMe
      const provides = this.getService(token);
      const isRequiredToken = Boolean(token.optional);

      if (typeof provides === 'undefined' && isRequiredToken) {
        throw new Error(`Token ${token.name} not registered or registered plugin does not provide a service. To use an optional plugin, use \`Token.optional\`.`);
      }

      return provides;
    };

    const renderer = FusionApp.createPlugin({
      deps: {
        criticalChunkIds: FusionApp.CriticalChunkIdsToken.optional,
        skipPrepare: SkipPrepareToken.optional
      },

      provides({
        skipPrepare
      }) {
        return (el, ctx) => {
          return (skipPrepare ? Promise.resolve() : prepare(el)).then(() => {
            if (render) {
              return render(el, ctx);
            }

            {
              return serverRender(el);
            }
          });
        };
      },

      middleware({
        criticalChunkIds
      }) {
        return (ctx, next) => {
          if (true && !ctx.element) {
            return next();
          }

          const markAsCritical = chunkId => {
            // Push to legacy context for backwards compat w/ legacy SSR template
            ctx.preloadChunks.push(chunkId); // Also use new service if registered

            if (criticalChunkIds) {
              let chunkIds = criticalChunkIds.from(ctx);
              chunkIds.add(chunkId);
            }
          };
          ctx.element = React.createElement(PrepareProvider, {
            markAsCritical: markAsCritical
          }, React.createElement(FusionContext.Provider, {
            value: ctx
          }, React.createElement(ServiceContext.Provider, {
            value: getService
          }, ctx.element)));
          return next();
        };
      }

    });
    super(root, renderer);
  }

}

exports.SkipPrepareToken = SkipPrepareToken;
exports.default = App;
exports.FusionContext = FusionContext;
exports.ProviderPlugin = plugin;
exports.ProvidedHOC = hoc;
exports.Provider = Provider;
exports.ServiceConsumer = ServiceConsumer;
exports.ServiceContext = ServiceContext;
exports.useService = useService;
exports.withServices = withServices;
exports.prepare = prepare;
exports.prepared = prepared;
exports.split = withAsyncComponent;
exports.exclude = traverseExclude;
exports.middleware = middleware;
