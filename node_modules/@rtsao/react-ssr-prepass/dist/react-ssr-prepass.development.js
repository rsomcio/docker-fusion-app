"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

var React = require("react");

var React__default = _interopDefault(React);

var is = require("react-is");

var is$1 = _interopDefault(require("object-is"));

function _extends() {
  return (_extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

var REACT_ELEMENT_TYPE = is.Element;

var REACT_PORTAL_TYPE = is.Portal;

var REACT_FRAGMENT_TYPE = is.Fragment;

var REACT_STRICT_MODE_TYPE = is.StrictMode;

var REACT_PROFILER_TYPE = is.Profiler;

var REACT_PROVIDER_TYPE = is.ContextProvider;

var REACT_CONTEXT_TYPE = is.ContextConsumer;

var REACT_CONCURRENT_MODE_TYPE = is.ConcurrentMode;

var REACT_FORWARD_REF_TYPE = is.ForwardRef;

var REACT_SUSPENSE_TYPE = is.Suspense;

var REACT_MEMO_TYPE = is.Memo;

var REACT_LAZY_TYPE = is.Lazy;

var toArray = React.Children.toArray;

var isAbstractElement = function(node) {
  return null !== node && "object" == typeof node;
};

var getChildrenArray = function(node) {
  return toArray(node).filter(isAbstractElement);
};

var computeProps = function(props, defaultProps) {
  return "object" == typeof defaultProps ? _extends({}, defaultProps, props) : props;
};

var currentContextStore = new Map();

var currentContextMap = {};

var prevContextMap = void 0;

var prevContextEntry = void 0;

var getCurrentContextMap = function() {
  return _extends({}, currentContextMap);
};

var getCurrentContextStore = function() {
  return new Map(currentContextStore);
};

var flushPrevContextMap = function() {
  var prev = prevContextMap;
  prevContextMap = void 0;
  return prev;
};

var flushPrevContextStore = function() {
  var prev = prevContextEntry;
  prevContextEntry = void 0;
  return prev;
};

var restoreContextMap = function(prev) {
  if (void 0 !== prev) {
    _extends(currentContextMap, prev);
  }
};

var restoreContextStore = function(prev) {
  if (void 0 !== prev) {
    currentContextStore.set(prev[0], prev[1]);
  }
};

var setCurrentContextMap = function(map) {
  prevContextMap = void 0;
  currentContextMap = map;
};

var setCurrentContextStore = function(store) {
  prevContextEntry = void 0;
  currentContextStore = store;
};

var readContextValue = function(context) {
  var value = currentContextStore.get(context);
  if (void 0 !== value) {
    return value;
  }
  return context._currentValue;
};

var emptyContext = {};

var maskContext = function(type) {
  var contextType = type.contextType;
  var contextTypes = type.contextTypes;
  if (contextType) {
    return readContextValue(contextType);
  } else if (!contextTypes) {
    return emptyContext;
  }
  var maskedContext = {};
  for (var name in contextTypes) {
    maskedContext[name] = currentContextMap[name];
  }
  return maskedContext;
};

var currentIdentity = null;

var setCurrentIdentity = function(id) {
  currentIdentity = id;
};

var getCurrentIdentity = function() {
  if (null === currentIdentity) {
    throw new Error("[react-ssr-prepass] Hooks can only be called inside the body of a function component. (https://fb.me/react-invalid-hook-call)");
  }
  return currentIdentity;
};

var firstWorkInProgressHook = null;

var workInProgressHook = null;

var isReRender = !1;

var didScheduleRenderPhaseUpdate = !1;

var renderPhaseUpdates = null;

var numberOfReRenders = 0;

var RE_RENDER_LIMIT = 25;

var setFirstHook = function(hook) {
  firstWorkInProgressHook = hook;
};

function createWorkInProgressHook() {
  if (null === workInProgressHook) {
    if (null === firstWorkInProgressHook) {
      isReRender = !1;
      firstWorkInProgressHook = workInProgressHook = {
        memoizedState: null,
        queue: null,
        next: null
      };
    } else {
      isReRender = !0;
      workInProgressHook = firstWorkInProgressHook;
    }
  } else if (null === workInProgressHook.next) {
    isReRender = !1;
    workInProgressHook = workInProgressHook.next = {
      memoizedState: null,
      queue: null,
      next: null
    };
  } else {
    isReRender = !0;
    workInProgressHook = workInProgressHook.next;
  }
  return workInProgressHook;
}

function basicStateReducer(state, action) {
  return "function" == typeof action ? action(state) : action;
}

function useReducer(reducer, initialArg, init) {
  var id = getCurrentIdentity();
  workInProgressHook = createWorkInProgressHook();
  if (isReRender) {
    var queue = workInProgressHook.queue;
    var dispatch = queue.dispatch;
    if (null !== renderPhaseUpdates) {
      var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
      if (void 0 !== firstRenderPhaseUpdate) {
        renderPhaseUpdates.delete(queue);
        var newState = workInProgressHook.memoizedState;
        var update = firstRenderPhaseUpdate;
        do {
          newState = reducer(newState, update.action);
          update = update.next;
        } while (null !== update);
        workInProgressHook.memoizedState = newState;
        return [ newState, dispatch ];
      }
    }
    return [ workInProgressHook.memoizedState, dispatch ];
  } else {
    var initialState;
    if (reducer === basicStateReducer) {
      initialState = "function" == typeof initialArg ? initialArg() : initialArg;
    } else {
      initialState = void 0 !== init ? init(initialArg) : initialArg;
    }
    workInProgressHook.memoizedState = initialState;
    var queue$1 = workInProgressHook.queue = {
      last: null,
      dispatch: null
    };
    var dispatch$1 = queue$1.dispatch = dispatchAction.bind(null, id, queue$1);
    return [ workInProgressHook.memoizedState, dispatch$1 ];
  }
}

function dispatchAction(componentIdentity, queue, action) {
  if (componentIdentity === getCurrentIdentity()) {
    didScheduleRenderPhaseUpdate = !0;
    var update = {
      action: action,
      next: null
    };
    if (null === renderPhaseUpdates) {
      renderPhaseUpdates = new Map();
    }
    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
    if (void 0 === firstRenderPhaseUpdate) {
      renderPhaseUpdates.set(queue, update);
    } else {
      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
      while (null !== lastRenderPhaseUpdate.next) {
        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      }
      lastRenderPhaseUpdate.next = update;
    }
  }
}

function noop() {}

var Dispatcher = {
  readContext: function readContext(context, _) {
    return readContextValue(context);
  },
  useContext: function useContext(context, _) {
    getCurrentIdentity();
    return readContextValue(context);
  },
  useMemo: function useMemo(nextCreate, deps) {
    getCurrentIdentity();
    var nextDeps = void 0 === deps ? null : deps;
    if (null !== (workInProgressHook = createWorkInProgressHook())) {
      var prevState = workInProgressHook.memoizedState;
      if (null !== prevState) {
        if (null !== nextDeps) {
          if (function areHookInputsEqual(nextDeps, prevDeps) {
            if (null === prevDeps) {
              return !1;
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (!is$1(nextDeps[i], prevDeps[i])) {
                return !1;
              }
            }
            return !0;
          }(nextDeps, prevState[1])) {
            return prevState[0];
          }
        }
      }
    }
    var nextValue = nextCreate();
    workInProgressHook.memoizedState = [ nextValue, nextDeps ];
    return nextValue;
  },
  useReducer: useReducer,
  useRef: function useRef(initialValue) {
    getCurrentIdentity();
    var previousRef = (workInProgressHook = createWorkInProgressHook()).memoizedState;
    if (null === previousRef) {
      var ref = {
        current: initialValue
      };
      workInProgressHook.memoizedState = ref;
      return ref;
    } else {
      return previousRef;
    }
  },
  useState: function useState(initialState) {
    return useReducer(basicStateReducer, initialState);
  },
  useCallback: function useCallback(callback, deps) {
    return callback;
  },
  useLayoutEffect: noop,
  useImperativeHandle: noop,
  useEffect: noop,
  useDebugValue: noop
};

var resolve = function(type) {
  type._status = 0;
  return type._ctor().then(function(Component) {
    if ("function" == typeof Component) {
      type._result = Component;
      type._status = 1;
    } else if (null !== Component && "object" == typeof Component && "function" == typeof Component.default) {
      type._result = Component.default;
      type._status = 1;
    } else {
      type._status = 2;
    }
  }).catch(function() {
    type._status = 2;
  });
};

var render = function(type, props, queue) {
  if (1 === type._status) {
    return React.createElement(type._result, props);
  }
  return null;
};

var makeFrame = function(type, props, thenable) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    id: getCurrentIdentity(),
    hook: firstWorkInProgressHook,
    kind: "frame.hooks",
    thenable: thenable,
    props: props,
    type: type
  };
};

var render$1 = function(type, props, queue) {
  try {
    return function renderWithHooks(Component, props, refOrContext) {
      var children = Component(props, refOrContext);
      while (numberOfReRenders < RE_RENDER_LIMIT && didScheduleRenderPhaseUpdate) {
        didScheduleRenderPhaseUpdate = !1;
        numberOfReRenders += 1;
        workInProgressHook = null;
        children = Component(props, refOrContext);
      }
      numberOfReRenders = 0;
      renderPhaseUpdates = null;
      workInProgressHook = null;
      return children;
    }(type, computeProps(props, type.defaultProps), maskContext(type));
  } catch (error) {
    if ("function" != typeof error.then) {
      throw error;
    }
    queue.push(makeFrame(type, props, error));
    return null;
  }
};

function _ref() {
  return !1;
}

function _ref2() {
  return null;
}

var createInstance = function(type, props) {
  var updater = {
    queue: queue = [],
    isMounted: _ref,
    enqueueForceUpdate: _ref2,
    enqueueReplaceState: function(instance, completeState) {
      if (instance._isMounted) {
        queue.length = 0;
        queue.push(completeState);
      }
    },
    enqueueSetState: function(instance, currentPartialState) {
      if (instance._isMounted) {
        queue.push(currentPartialState);
      }
    }
  };
  var queue;
  var computedProps = computeProps(props, type.defaultProps);
  var context = maskContext(type);
  var instance = new type(computedProps, context, updater);
  instance.props = computedProps;
  instance.context = context;
  instance.updater = updater;
  instance._isMounted = !0;
  if (void 0 === instance.state) {
    instance.state = null;
  }
  if ("function" == typeof type.getDerivedStateFromProps) {
    var state = (0, type.getDerivedStateFromProps)(instance.props, instance.state);
    if (null != state) {
      instance.state = _extends({}, instance.state, state);
    }
  } else if ("function" == typeof instance.componentWillMount) {
    instance.componentWillMount();
  } else if ("function" == typeof instance.UNSAFE_componentWillMount) {
    instance.UNSAFE_componentWillMount();
  }
  return instance;
};

var makeFrame$1 = function(type, instance, thenable) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    thenable: thenable,
    kind: "frame.class",
    instance: instance,
    type: type
  };
};

var render$2 = function(type, instance, queue) {
  !function(instance) {
    var queue = instance.updater.queue;
    if (queue.length > 0) {
      var nextState = _extends({}, instance.state);
      for (var i = 0, l = queue.length; i < l; i++) {
        var partial = queue[i];
        var partialState = "function" == typeof partial ? partial.call(instance, nextState, instance.props, instance.context) : partial;
        if (null !== partialState) {
          _extends(nextState, partialState);
        }
      }
      instance.state = nextState;
      queue.length = 0;
    }
  }(instance);
  var child = null;
  try {
    child = instance.render();
  } catch (error) {
    if ("function" != typeof error.then) {
      throw error;
    }
    queue.push(makeFrame$1(type, instance, error));
    return null;
  }
  if (void 0 !== type.childContextTypes && "function" == typeof instance.getChildContext) {
    var childContext = instance.getChildContext();
    if (null !== childContext && "object" == typeof childContext) {
      !function(map) {
        prevContextMap = {};
        for (var name in map) {
          prevContextMap[name] = currentContextMap[name];
          currentContextMap[name] = map[name];
        }
      }(childContext);
    }
  }
  if ("function" != typeof instance.getDerivedStateFromProps && ("function" == typeof instance.componentWillMount || "function" == typeof instance.UNSAFE_componentWillMount) && "function" == typeof instance.componentWillUnmount) {
    try {
      instance.componentWillUnmount();
    } catch (_err) {}
  }
  instance._isMounted = !1;
  return child;
};

var YIELD_AFTER_MS = "production" !== process.env.NODE_ENV ? 20 : 5;

var render$3 = function(type, props, queue, visitor, element) {
  return (Comp = type).prototype && Comp.prototype.isReactComponent ? function(type, props, queue, visitor, element) {
    setCurrentIdentity(null);
    var instance = createInstance(type, props);
    var promise = visitor(element, instance);
    if (promise) {
      queue.push(makeFrame$1(type, instance, promise));
      return null;
    }
    return render$2(type, instance, queue);
  }(type, props, queue, visitor, element) : function(type, props, queue, visitor, element) {
    setFirstHook(null);
    setCurrentIdentity({});
    var promise = visitor(element);
    if (promise) {
      queue.push(makeFrame(type, props, promise));
      return null;
    }
    return render$1(type, props, queue);
  }(type, props, queue, visitor, element);
  var Comp;
};

var visitElement = function(element, queue, visitor) {
  switch (function(x) {
    switch (x.$$typeof) {
     case REACT_PORTAL_TYPE:
      return REACT_PORTAL_TYPE;

     case REACT_ELEMENT_TYPE:
      switch (x.type) {
       case REACT_CONCURRENT_MODE_TYPE:
        return REACT_CONCURRENT_MODE_TYPE;

       case REACT_FRAGMENT_TYPE:
        return REACT_FRAGMENT_TYPE;

       case REACT_PROFILER_TYPE:
        return REACT_PROFILER_TYPE;

       case REACT_STRICT_MODE_TYPE:
        return REACT_STRICT_MODE_TYPE;

       case REACT_SUSPENSE_TYPE:
        return REACT_SUSPENSE_TYPE;

       default:
        switch (x.type && x.type.$$typeof) {
         case REACT_LAZY_TYPE:
          return REACT_LAZY_TYPE;

         case REACT_MEMO_TYPE:
          return REACT_MEMO_TYPE;

         case REACT_CONTEXT_TYPE:
          return REACT_CONTEXT_TYPE;

         case REACT_PROVIDER_TYPE:
          return REACT_PROVIDER_TYPE;

         case REACT_FORWARD_REF_TYPE:
          return REACT_FORWARD_REF_TYPE;

         default:
          return REACT_ELEMENT_TYPE;
        }
      }

     default:
      return;
    }
  }(element)) {
   case REACT_SUSPENSE_TYPE:
   case REACT_STRICT_MODE_TYPE:
   case REACT_CONCURRENT_MODE_TYPE:
   case REACT_PROFILER_TYPE:
   case REACT_FRAGMENT_TYPE:
    return getChildrenArray(element.props.children);

   case REACT_PROVIDER_TYPE:
    var ref = element.props;
    var children = ref.children;
    !function(context, value) {
      prevContextEntry = [ context, currentContextStore.get(context) ];
      currentContextStore.set(context, value);
    }(element.type._context, ref.value);
    return getChildrenArray(children);

   case REACT_CONTEXT_TYPE:
    var children$1 = element.props.children;
    if ("function" == typeof children$1) {
      var type = element.type;
      var value$1 = readContextValue("object" == typeof type._context ? type._context : type);
      return getChildrenArray(children$1(value$1));
    } else {
      return [];
    }

   case REACT_LAZY_TYPE:
    var child = function(type, props, queue) {
      if (2 !== type._status && 1 !== type._status) {
        queue.push({
          contextMap: getCurrentContextMap(),
          contextStore: getCurrentContextStore(),
          kind: "frame.lazy",
          thenable: resolve(type),
          props: props,
          type: type
        });
        return null;
      }
      return render(type, props);
    }(element.type, element.props, queue);
    return getChildrenArray(child);

   case REACT_MEMO_TYPE:
    var child$1 = React.createElement(element.type.type, element.props);
    return getChildrenArray(child$1);

   case REACT_FORWARD_REF_TYPE:
    var ref$2 = element.type;
    var type$3 = ref$2.render;
    var props = computeProps(element.props, ref$2.defaultProps);
    var fauxElement = React.createElement(render$3, props);
    var child$2 = render$3(type$3, props, queue, visitor, fauxElement);
    return getChildrenArray(child$2);

   case REACT_ELEMENT_TYPE:
    if ("string" == typeof element.type) {
      return getChildrenArray(element.props.children);
    } else {
      var child$3 = render$3(element.type, element.props, queue, visitor, element);
      return getChildrenArray(child$3);
    }

   case REACT_PORTAL_TYPE:
   default:
    return [];
  }
};

var visitLoop = function(traversalChildren, traversalMap, traversalStore, queue, visitor) {
  var start = Date.now();
  while (traversalChildren.length > 0) {
    var element = traversalChildren[traversalChildren.length - 1].shift();
    if (void 0 !== element) {
      var children = visitElement(element, queue, visitor);
      traversalChildren.push(children);
      traversalMap.push(flushPrevContextMap());
      traversalStore.push(flushPrevContextStore());
    } else {
      traversalChildren.pop();
      restoreContextMap(traversalMap.pop());
      restoreContextStore(traversalStore.pop());
    }
    if (Date.now() - start > YIELD_AFTER_MS) {
      return !0;
    }
  }
  return !1;
};

var makeYieldFrame = function(traversalChildren, traversalMap, traversalStore) {
  return {
    contextMap: getCurrentContextMap(),
    contextStore: getCurrentContextStore(),
    thenable: Promise.resolve(),
    kind: "frame.yield",
    children: traversalChildren,
    map: traversalMap,
    store: traversalStore
  };
};

var visitChildren = function(init, queue, visitor) {
  var traversalChildren = [ init ];
  var traversalMap = [ flushPrevContextMap() ];
  var traversalStore = [ flushPrevContextStore() ];
  if (visitLoop(traversalChildren, traversalMap, traversalStore, queue, visitor)) {
    queue.unshift(makeYieldFrame(traversalChildren, traversalMap, traversalStore));
  }
};

var resumeVisitChildren = function(frame, queue, visitor) {
  setCurrentIdentity(null);
  setCurrentContextMap(frame.contextMap);
  setCurrentContextStore(frame.contextStore);
  if (visitLoop(frame.children, frame.map, frame.store, queue, visitor)) {
    queue.unshift(makeYieldFrame(frame.children, frame.map, frame.store));
  }
};

var ReactCurrentDispatcher = React__default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher;

var prevDispatcher = ReactCurrentDispatcher.current;

var updateWithFrame = function(frame, queue, visitor) {
  if ("frame.yield" === frame.kind) {
    var yieldFrame = frame;
    return new Promise(function _ref(resolve) {
      setImmediate(function() {
        prevDispatcher = ReactCurrentDispatcher.current;
        ReactCurrentDispatcher.current = Dispatcher;
        resumeVisitChildren(yieldFrame, queue, visitor);
        ReactCurrentDispatcher.current = prevDispatcher;
        resolve();
      });
    });
  }
  return frame.thenable.then(function() {
    prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = Dispatcher;
    var children = [];
    if ("frame.class" === frame.kind) {
      children = function(queue, frame) {
        setCurrentIdentity(null);
        setCurrentContextMap(frame.contextMap);
        setCurrentContextStore(frame.contextStore);
        return render$2(frame.type, frame.instance, queue);
      }(queue, frame);
    } else if ("frame.hooks" === frame.kind) {
      children = function(queue, frame) {
        setFirstHook(frame.hook);
        setCurrentIdentity(frame.id);
        setCurrentContextMap(frame.contextMap);
        setCurrentContextStore(frame.contextStore);
        return render$1(frame.type, frame.props, queue);
      }(queue, frame);
    } else if ("frame.lazy" === frame.kind) {
      children = function(queue, frame) {
        setCurrentIdentity(null);
        setCurrentContextMap(frame.contextMap);
        setCurrentContextStore(frame.contextStore);
        return render(frame.type, frame.props);
      }(0, frame);
    }
    visitChildren(getChildrenArray(children), queue, visitor);
    ReactCurrentDispatcher.current = prevDispatcher;
  });
};

var flushFrames = function(queue, visitor) {
  if (0 === queue.length) {
    return Promise.resolve();
  }
  return updateWithFrame(queue.shift(), queue, visitor).then(function() {
    return flushFrames(queue, visitor);
  });
};

var defaultVisitor = function() {
  return;
};

module.exports = function(element, visitor) {
  var queue = [];
  var fn = void 0 !== visitor ? visitor : defaultVisitor;
  setCurrentContextMap({});
  setCurrentContextStore(new Map());
  try {
    prevDispatcher = ReactCurrentDispatcher.current;
    ReactCurrentDispatcher.current = Dispatcher;
    visitChildren(getChildrenArray(element), queue, fn);
  } catch (error) {
    return Promise.reject(error);
  } finally {
    ReactCurrentDispatcher.current = prevDispatcher;
  }
  return flushFrames(queue, fn);
};
//# sourceMappingURL=react-ssr-prepass.development.js.map
